!function (a) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = a(); else if ("function" == typeof define && define.amd) define([], a); else { var b; b = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, b.Matter = a() } }(function () {
  return function a(b, c, d) { function e(g, h) { if (!c[g]) { if (!b[g]) { var i = "function" == typeof require && require; if (!h && i) return i(g, !0); if (f) return f(g, !0); var j = new Error("Cannot find module '" + g + "'"); throw j.code = "MODULE_NOT_FOUND", j } var k = c[g] = { exports: {} }; b[g][0].call(k.exports, function (a) { var c = b[g][1][a]; return e(c ? c : a) }, k, k.exports, a, b, c, d) } return c[g].exports } for (var f = "function" == typeof require && require, g = 0; g < d.length; g++)e(d[g]); return e }({
    1: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../geometry/Vertices"), f = a("../geometry/Vector"), g = a("../core/Sleeping"), h = (a("../render/Render"), a("../core/Common")), i = a("../geometry/Bounds"), j = a("../geometry/Axes"); !function () { d._inertiaScale = 4; var a = 1, b = -1, c = 1; d.create = function (a) { var b = { id: h.nextId(), type: "body", label: "Body", parts: [], angle: 0, vertices: e.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"), position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isStatic: !1, isSleeping: !1, motion: 0, sleepThreshold: 60, density: .001, restitution: 0, friction: .1, frictionStatic: .5, frictionAir: .01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: .05, timeScale: 1, render: { visible: !0, sprite: { xScale: 1, yScale: 1 }, lineWidth: 1.5 } }, c = h.extend(b, a); return k(c, a), c }, d.nextGroup = function (c) { return c ? b-- : a++ }, d.nextCategory = function () { return c <<= 1 }; var k = function (a, b) { d.set(a, { bounds: a.bounds || i.create(a.vertices), positionPrev: a.positionPrev || f.clone(a.position), anglePrev: a.anglePrev || a.angle, vertices: a.vertices, parts: a.parts || [a], isStatic: a.isStatic, isSleeping: a.isSleeping, parent: a.parent || a }), e.rotate(a.vertices, a.angle, a.position), j.rotate(a.axes, a.angle), i.update(a.bounds, a.vertices, a.velocity), d.set(a, { axes: b.axes || a.axes, area: b.area || a.area, mass: b.mass || a.mass, inertia: b.inertia || a.inertia }); var c = a.isStatic ? "#eeeeee" : h.choose(["#556270", "#4ECDC4", "#C7F464", "#FF6B6B", "#C44D58"]), g = h.shadeColor(c, -20); a.render.fillStyle = a.render.fillStyle || c, a.render.strokeStyle = a.render.strokeStyle || g }; d.set = function (a, b, c) { var e; "string" == typeof b && (e = b, b = {}, b[e] = c); for (e in b) if (c = b[e], b.hasOwnProperty(e)) switch (e) { case "isStatic": d.setStatic(a, c); break; case "isSleeping": g.set(a, c); break; case "mass": d.setMass(a, c); break; case "density": d.setDensity(a, c); break; case "inertia": d.setInertia(a, c); break; case "vertices": d.setVertices(a, c); break; case "position": d.setPosition(a, c); break; case "angle": d.setAngle(a, c); break; case "velocity": d.setVelocity(a, c); break; case "angularVelocity": d.setAngularVelocity(a, c); break; case "parts": d.setParts(a, c); break; default: a[e] = c } }, d.setStatic = function (a, b) { for (var c = 0; c < a.parts.length; c++) { var d = a.parts[c]; d.isStatic = b, b && (d.restitution = 0, d.friction = 1, d.mass = d.inertia = d.density = 1 / 0, d.inverseMass = d.inverseInertia = 0, d.positionPrev.x = d.position.x, d.positionPrev.y = d.position.y, d.anglePrev = d.angle, d.angularVelocity = 0, d.speed = 0, d.angularSpeed = 0, d.motion = 0) } }, d.setMass = function (a, b) { a.mass = b, a.inverseMass = 1 / a.mass, a.density = a.mass / a.area }, d.setDensity = function (a, b) { d.setMass(a, b * a.area), a.density = b }, d.setInertia = function (a, b) { a.inertia = b, a.inverseInertia = 1 / a.inertia }, d.setVertices = function (a, b) { b[0].body === a ? a.vertices = b : a.vertices = e.create(b, a), a.axes = j.fromVertices(a.vertices), a.area = e.area(a.vertices), d.setMass(a, a.density * a.area); var c = e.centre(a.vertices); e.translate(a.vertices, c, -1), d.setInertia(a, d._inertiaScale * e.inertia(a.vertices, a.mass)), e.translate(a.vertices, a.position), i.update(a.bounds, a.vertices, a.velocity) }, d.setParts = function (a, b, c) { var f; for (b = b.slice(0), a.parts.length = 0, a.parts.push(a), a.parent = a, f = 0; f < b.length; f++) { var g = b[f]; g !== a && (g.parent = a, a.parts.push(g)) } if (1 !== a.parts.length) { if (c = "undefined" != typeof c ? c : !0) { var h = []; for (f = 0; f < b.length; f++)h = h.concat(b[f].vertices); e.clockwiseSort(h); var i = e.hull(h), j = e.centre(i); d.setVertices(a, i), e.translate(a.vertices, j) } var k = l(a); a.area = k.area, a.parent = a, a.position.x = k.centre.x, a.position.y = k.centre.y, a.positionPrev.x = k.centre.x, a.positionPrev.y = k.centre.y, d.setMass(a, k.mass), d.setInertia(a, k.inertia), d.setPosition(a, k.centre) } }, d.setPosition = function (a, b) { var c = f.sub(b, a.position); a.positionPrev.x += c.x, a.positionPrev.y += c.y; for (var d = 0; d < a.parts.length; d++) { var g = a.parts[d]; g.position.x += c.x, g.position.y += c.y, e.translate(g.vertices, c), i.update(g.bounds, g.vertices, a.velocity) } }, d.setAngle = function (a, b) { var c = b - a.angle; a.anglePrev += c; for (var d = 0; d < a.parts.length; d++) { var g = a.parts[d]; g.angle += c, e.rotate(g.vertices, c, a.position), j.rotate(g.axes, c), i.update(g.bounds, g.vertices, a.velocity), d > 0 && f.rotateAbout(g.position, c, a.position, g.position) } }, d.setVelocity = function (a, b) { a.positionPrev.x = a.position.x - b.x, a.positionPrev.y = a.position.y - b.y, a.velocity.x = b.x, a.velocity.y = b.y, a.speed = f.magnitude(a.velocity) }, d.setAngularVelocity = function (a, b) { a.anglePrev = a.angle - b, a.angularVelocity = b, a.angularSpeed = Math.abs(a.angularVelocity) }, d.translate = function (a, b) { d.setPosition(a, f.add(a.position, b)) }, d.rotate = function (a, b) { d.setAngle(a, a.angle + b) }, d.scale = function (a, b, c, f) { for (var g = 0; g < a.parts.length; g++) { var h = a.parts[g]; e.scale(h.vertices, b, c, a.position), h.axes = j.fromVertices(h.vertices), a.isStatic || (h.area = e.area(h.vertices), d.setMass(h, a.density * h.area), e.translate(h.vertices, { x: -h.position.x, y: -h.position.y }), d.setInertia(h, e.inertia(h.vertices, h.mass)), e.translate(h.vertices, { x: h.position.x, y: h.position.y })), i.update(h.bounds, h.vertices, a.velocity) } if (!a.isStatic) { var k = l(a); a.area = k.area, d.setMass(a, k.mass), d.setInertia(a, k.inertia) } }, d.update = function (a, b, c, d) { var g = Math.pow(b * c * a.timeScale, 2), h = 1 - a.frictionAir * c * a.timeScale, k = a.position.x - a.positionPrev.x, l = a.position.y - a.positionPrev.y; a.velocity.x = k * h * d + a.force.x / a.mass * g, a.velocity.y = l * h * d + a.force.y / a.mass * g, a.positionPrev.x = a.position.x, a.positionPrev.y = a.position.y, a.position.x += a.velocity.x, a.position.y += a.velocity.y, a.angularVelocity = (a.angle - a.anglePrev) * h * d + a.torque / a.inertia * g, a.anglePrev = a.angle, a.angle += a.angularVelocity, a.speed = f.magnitude(a.velocity), a.angularSpeed = Math.abs(a.angularVelocity); for (var m = 0; m < a.parts.length; m++) { var n = a.parts[m]; e.translate(n.vertices, a.velocity), m > 0 && (n.position.x += a.velocity.x, n.position.y += a.velocity.y), 0 !== a.angularVelocity && (e.rotate(n.vertices, a.angularVelocity, a.position), j.rotate(n.axes, a.angularVelocity), m > 0 && f.rotateAbout(n.position, a.angularVelocity, a.position, n.position)), i.update(n.bounds, n.vertices, a.velocity) } }, d.applyForce = function (a, b, c) { a.force.x += c.x, a.force.y += c.y; var d = { x: b.x - a.position.x, y: b.y - a.position.y }; a.torque += (d.x * c.y - d.y * c.x) * a.inverseInertia }; var l = function (a) { for (var b = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } }, c = 1 === a.parts.length ? 0 : 1; c < a.parts.length; c++) { var d = a.parts[c]; b.mass += d.mass, b.area += d.area, b.inertia += d.inertia, b.centre = f.add(b.centre, f.mult(d.position, d.mass !== 1 / 0 ? d.mass : 1)) } return b.centre = f.div(b.centre, b.mass !== 1 / 0 ? b.mass : a.parts.length), b } }() }, { "../core/Common": 14, "../core/Sleeping": 20, "../geometry/Axes": 23, "../geometry/Bounds": 24, "../geometry/Vector": 26, "../geometry/Vertices": 27, "../render/Render": 29 }], 2: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../core/Events"), f = a("../core/Common"), g = a("./Body"); !function () { d.create = function (a) { return f.extend({ id: f.nextId(), type: "composite", parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: "Composite" }, a) }, d.setModified = function (a, b, c, e) { if (a.isModified = b, c && a.parent && d.setModified(a.parent, b, c, e), e) for (var f = 0; f < a.composites.length; f++) { var g = a.composites[f]; d.setModified(g, b, c, e) } }, d.add = function (a, b) { var c = [].concat(b); e.trigger(a, "beforeAdd", { object: b }); for (var g = 0; g < c.length; g++) { var h = c[g]; switch (h.type) { case "body": if (h.parent !== h) { f.log("Composite.add: skipped adding a compound body part (you must add its parent instead)", "warn"); break } d.addBody(a, h); break; case "constraint": d.addConstraint(a, h); break; case "composite": d.addComposite(a, h); break; case "mouseConstraint": d.addConstraint(a, h.constraint) } } return e.trigger(a, "afterAdd", { object: b }), a }, d.remove = function (a, b, c) { var f = [].concat(b); e.trigger(a, "beforeRemove", { object: b }); for (var g = 0; g < f.length; g++) { var h = f[g]; switch (h.type) { case "body": d.removeBody(a, h, c); break; case "constraint": d.removeConstraint(a, h, c); break; case "composite": d.removeComposite(a, h, c); break; case "mouseConstraint": d.removeConstraint(a, h.constraint) } } return e.trigger(a, "afterRemove", { object: b }), a }, d.addComposite = function (a, b) { return a.composites.push(b), b.parent = a, d.setModified(a, !0, !0, !1), a }, d.removeComposite = function (a, b, c) { var e = f.indexOf(a.composites, b); if (-1 !== e && (d.removeCompositeAt(a, e), d.setModified(a, !0, !0, !1)), c) for (var g = 0; g < a.composites.length; g++)d.removeComposite(a.composites[g], b, !0); return a }, d.removeCompositeAt = function (a, b) { return a.composites.splice(b, 1), d.setModified(a, !0, !0, !1), a }, d.addBody = function (a, b) { return a.bodies.push(b), d.setModified(a, !0, !0, !1), a }, d.removeBody = function (a, b, c) { var e = f.indexOf(a.bodies, b); if (-1 !== e && (d.removeBodyAt(a, e), d.setModified(a, !0, !0, !1)), c) for (var g = 0; g < a.composites.length; g++)d.removeBody(a.composites[g], b, !0); return a }, d.removeBodyAt = function (a, b) { return a.bodies.splice(b, 1), d.setModified(a, !0, !0, !1), a }, d.addConstraint = function (a, b) { return a.constraints.push(b), d.setModified(a, !0, !0, !1), a }, d.removeConstraint = function (a, b, c) { var e = f.indexOf(a.constraints, b); if (-1 !== e && d.removeConstraintAt(a, e), c) for (var g = 0; g < a.composites.length; g++)d.removeConstraint(a.composites[g], b, !0); return a }, d.removeConstraintAt = function (a, b) { return a.constraints.splice(b, 1), d.setModified(a, !0, !0, !1), a }, d.clear = function (a, b, c) { if (c) for (var e = 0; e < a.composites.length; e++)d.clear(a.composites[e], b, !0); return b ? a.bodies = a.bodies.filter(function (a) { return a.isStatic }) : a.bodies.length = 0, a.constraints.length = 0, a.composites.length = 0, d.setModified(a, !0, !0, !1), a }, d.allBodies = function (a) { for (var b = [].concat(a.bodies), c = 0; c < a.composites.length; c++)b = b.concat(d.allBodies(a.composites[c])); return b }, d.allConstraints = function (a) { for (var b = [].concat(a.constraints), c = 0; c < a.composites.length; c++)b = b.concat(d.allConstraints(a.composites[c])); return b }, d.allComposites = function (a) { for (var b = [].concat(a.composites), c = 0; c < a.composites.length; c++)b = b.concat(d.allComposites(a.composites[c])); return b }, d.get = function (a, b, c) { var e, f; switch (c) { case "body": e = d.allBodies(a); break; case "constraint": e = d.allConstraints(a); break; case "composite": e = d.allComposites(a).concat(a) }return e ? (f = e.filter(function (a) { return a.id.toString() === b.toString() }), 0 === f.length ? null : f[0]) : null }, d.move = function (a, b, c) { return d.remove(a, b), d.add(c, b), a }, d.rebase = function (a) { for (var b = d.allBodies(a).concat(d.allConstraints(a)).concat(d.allComposites(a)), c = 0; c < b.length; c++)b[c].id = f.nextId(); return d.setModified(a, !0, !0, !1), a }, d.translate = function (a, b, c) { for (var e = c ? d.allBodies(a) : a.bodies, f = 0; f < e.length; f++)g.translate(e[f], b); return d.setModified(a, !0, !0, !1), a }, d.rotate = function (a, b, c, e) { for (var f = Math.cos(b), h = Math.sin(b), i = e ? d.allBodies(a) : a.bodies, j = 0; j < i.length; j++) { var k = i[j], l = k.position.x - c.x, m = k.position.y - c.y; g.setPosition(k, { x: c.x + (l * f - m * h), y: c.y + (l * h + m * f) }), g.rotate(k, b) } return d.setModified(a, !0, !0, !1), a }, d.scale = function (a, b, c, e, f) { for (var h = f ? d.allBodies(a) : a.bodies, i = 0; i < h.length; i++) { var j = h[i], k = j.position.x - e.x, l = j.position.y - e.y; g.setPosition(j, { x: e.x + k * b, y: e.y + l * c }), g.scale(j, b, c) } return d.setModified(a, !0, !0, !1), a } }() }, { "../core/Common": 14, "../core/Events": 16, "./Body": 1 }], 3: [function (a, b, c) { var d = {}; b.exports = d; var e = a("./Composite"), f = (a("../constraint/Constraint"), a("../core/Common")); !function () { d.create = function (a) { var b = e.create(), c = { label: "World", gravity: { x: 0, y: 1 }, bounds: { min: { x: -(1 / 0), y: -(1 / 0) }, max: { x: 1 / 0, y: 1 / 0 } } }; return f.extend(b, c, a) } }() }, { "../constraint/Constraint": 12, "../core/Common": 14, "./Composite": 2 }], 4: [function (a, b, c) { var d = {}; b.exports = d, function () { d.create = function (a) { return { id: d.id(a), vertex: a, normalImpulse: 0, tangentImpulse: 0 } }, d.id = function (a) { return a.body.id + "_" + a.index } }() }, {}], 5: [function (a, b, c) { var d = {}; b.exports = d; var e = a("./SAT"), f = a("./Pair"), g = a("../geometry/Bounds"); !function () { d.collisions = function (a, b) { for (var c = [], h = b.pairs.table, i = 0; i < a.length; i++) { var j = a[i][0], k = a[i][1]; if ((!j.isStatic && !j.isSleeping || !k.isStatic && !k.isSleeping) && d.canCollide(j.collisionFilter, k.collisionFilter) && g.overlaps(j.bounds, k.bounds)) for (var l = j.parts.length > 1 ? 1 : 0; l < j.parts.length; l++)for (var m = j.parts[l], n = k.parts.length > 1 ? 1 : 0; n < k.parts.length; n++) { var o = k.parts[n]; if (m === j && o === k || g.overlaps(m.bounds, o.bounds)) { var p, q = f.id(m, o), r = h[q]; p = r && r.isActive ? r.collision : null; var s = e.collides(m, o, p); s.collided && c.push(s) } } } return c }, d.bruteForce = function (a, b) { for (var c = [], h = b.pairs.table, i = 0; i < a.length; i++)for (var j = i + 1; j < a.length; j++) { var k = a[i], l = a[j]; if ((!k.isStatic && !k.isSleeping || !l.isStatic && !l.isSleeping) && d.canCollide(k.collisionFilter, l.collisionFilter) && g.overlaps(k.bounds, l.bounds)) { var m, n = f.id(k, l), o = h[n]; m = o && o.isActive ? o.collision : null; var p = e.collides(k, l, m); p.collided && c.push(p) } } return c }, d.canCollide = function (a, b) { return a.group === b.group && 0 !== a.group ? a.group > 0 : 0 !== (a.mask & b.category) && 0 !== (b.mask & a.category) } }() }, { "../geometry/Bounds": 24, "./Pair": 7, "./SAT": 11 }], 6: [function (a, b, c) { var d = {}; b.exports = d; var e = a("./Pair"), f = a("./Detector"), g = a("../core/Common"); !function () { d.create = function (a) { var b = { controller: d, detector: f.collisions, buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48 }; return g.extend(b, a) }, d.update = function (c, d, e, f) { var g, m, n, o, p, q = e.world, r = c.buckets, s = !1; for (g = 0; g < d.length; g++) { var t = d[g]; if ((!t.isSleeping || f) && !(t.bounds.max.x < 0 || t.bounds.min.x > q.bounds.width || t.bounds.max.y < 0 || t.bounds.min.y > q.bounds.height)) { var u = b(c, t); if (!t.region || u.id !== t.region.id || f) { (!t.region || f) && (t.region = u); var v = a(u, t.region); for (m = v.startCol; m <= v.endCol; m++)for (n = v.startRow; n <= v.endRow; n++) { p = h(m, n), o = r[p]; var w = m >= u.startCol && m <= u.endCol && n >= u.startRow && n <= u.endRow, x = m >= t.region.startCol && m <= t.region.endCol && n >= t.region.startRow && n <= t.region.endRow; !w && x && x && o && k(c, o, t), (t.region === u || w && !x || f) && (o || (o = i(r, p)), j(c, o, t)) } t.region = u, s = !0 } } } s && (c.pairsList = l(c)) }, d.clear = function (a) { a.buckets = {}, a.pairs = {}, a.pairsList = [] }; var a = function (a, b) { var d = Math.min(a.startCol, b.startCol), e = Math.max(a.endCol, b.endCol), f = Math.min(a.startRow, b.startRow), g = Math.max(a.endRow, b.endRow); return c(d, e, f, g) }, b = function (a, b) { var d = b.bounds, e = Math.floor(d.min.x / a.bucketWidth), f = Math.floor(d.max.x / a.bucketWidth), g = Math.floor(d.min.y / a.bucketHeight), h = Math.floor(d.max.y / a.bucketHeight); return c(e, f, g, h) }, c = function (a, b, c, d) { return { id: a + "," + b + "," + c + "," + d, startCol: a, endCol: b, startRow: c, endRow: d } }, h = function (a, b) { return a + "," + b }, i = function (a, b) { var c = a[b] = []; return c }, j = function (a, b, c) { for (var d = 0; d < b.length; d++) { var f = b[d]; if (!(c.id === f.id || c.isStatic && f.isStatic)) { var g = e.id(c, f), h = a.pairs[g]; h ? h[2] += 1 : a.pairs[g] = [c, f, 1] } } b.push(c) }, k = function (a, b, c) { b.splice(g.indexOf(b, c), 1); for (var d = 0; d < b.length; d++) { var f = b[d], h = e.id(c, f), i = a.pairs[h]; i && (i[2] -= 1) } }, l = function (a) { var b, c, d = []; b = g.keys(a.pairs); for (var e = 0; e < b.length; e++)c = a.pairs[b[e]], c[2] > 0 ? d.push(c) : delete a.pairs[b[e]]; return d } }() }, { "../core/Common": 14, "./Detector": 5, "./Pair": 7 }], 7: [function (a, b, c) { var d = {}; b.exports = d; var e = a("./Contact"); !function () { d.create = function (a, b) { var c = a.bodyA, e = a.bodyB, f = a.parentA, g = a.parentB, h = { id: d.id(c, e), bodyA: c, bodyB: e, contacts: {}, activeContacts: [], separation: 0, isActive: !0, timeCreated: b, timeUpdated: b, inverseMass: f.inverseMass + g.inverseMass, friction: Math.min(f.friction, g.friction), frictionStatic: Math.max(f.frictionStatic, g.frictionStatic), restitution: Math.max(f.restitution, g.restitution), slop: Math.max(f.slop, g.slop) }; return d.update(h, a, b), h }, d.update = function (a, b, c) { var f = a.contacts, g = b.supports, h = a.activeContacts, i = b.parentA, j = b.parentB; if (a.collision = b, a.inverseMass = i.inverseMass + j.inverseMass, a.friction = Math.min(i.friction, j.friction), a.frictionStatic = Math.max(i.frictionStatic, j.frictionStatic), a.restitution = Math.max(i.restitution, j.restitution), a.slop = Math.max(i.slop, j.slop), h.length = 0, b.collided) { for (var k = 0; k < g.length; k++) { var l = g[k], m = e.id(l), n = f[m]; n ? h.push(n) : h.push(f[m] = e.create(l)) } a.separation = b.depth, d.setActive(a, !0, c) } else a.isActive === !0 && d.setActive(a, !1, c) }, d.setActive = function (a, b, c) { b ? (a.isActive = !0, a.timeUpdated = c) : (a.isActive = !1, a.activeContacts.length = 0) }, d.id = function (a, b) { return a.id < b.id ? a.id + "_" + b.id : b.id + "_" + a.id } }() }, { "./Contact": 4 }], 8: [function (a, b, c) { var d = {}; b.exports = d; var e = a("./Pair"), f = a("../core/Common"); !function () { var a = 1e3; d.create = function (a) { return f.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, a) }, d.update = function (a, b, c) { var d, g, h, i, j = a.list, k = a.table, l = a.collisionStart, m = a.collisionEnd, n = a.collisionActive, o = []; for (l.length = 0, m.length = 0, n.length = 0, i = 0; i < b.length; i++)d = b[i], d.collided && (g = e.id(d.bodyA, d.bodyB), o.push(g), h = k[g], h ? (h.isActive ? n.push(h) : l.push(h), e.update(h, d, c)) : (h = e.create(d, c), k[g] = h, l.push(h), j.push(h))); for (i = 0; i < j.length; i++)h = j[i], h.isActive && -1 === f.indexOf(o, h.id) && (e.setActive(h, !1, c), m.push(h)) }, d.removeOld = function (b, c) { var d, e, f, g, h = b.list, i = b.table, j = []; for (g = 0; g < h.length; g++)d = h[g], e = d.collision, e.bodyA.isSleeping || e.bodyB.isSleeping ? d.timeUpdated = c : c - d.timeUpdated > a && j.push(g); for (g = 0; g < j.length; g++)f = j[g] - g, d = h[f], delete i[d.id], h.splice(f, 1) }, d.clear = function (a) { return a.table = {}, a.list.length = 0, a.collisionStart.length = 0, a.collisionActive.length = 0, a.collisionEnd.length = 0, a } }() }, { "../core/Common": 14, "./Pair": 7 }], 9: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../geometry/Vector"), f = a("./SAT"), g = a("../geometry/Bounds"), h = a("../factory/Bodies"), i = a("../geometry/Vertices"); !function () { d.ray = function (a, b, c, d) { d = d || 1e-100; for (var i = e.angle(b, c), j = e.magnitude(e.sub(b, c)), k = .5 * (c.x + b.x), l = .5 * (c.y + b.y), m = h.rectangle(k, l, j, d, { angle: i }), n = [], o = 0; o < a.length; o++) { var p = a[o]; if (g.overlaps(p.bounds, m.bounds)) for (var q = 1 === p.parts.length ? 0 : 1; q < p.parts.length; q++) { var r = p.parts[q]; if (g.overlaps(r.bounds, m.bounds)) { var s = f.collides(r, m); if (s.collided) { s.body = s.bodyA = s.bodyB = p, n.push(s); break } } } } return n }, d.region = function (a, b, c) { for (var d = [], e = 0; e < a.length; e++) { var f = a[e], h = g.overlaps(f.bounds, b); (h && !c || !h && c) && d.push(f) } return d }, d.point = function (a, b) { for (var c = [], d = 0; d < a.length; d++) { var e = a[d]; if (g.contains(e.bounds, b)) for (var f = 1 === e.parts.length ? 0 : 1; f < e.parts.length; f++) { var h = e.parts[f]; if (g.contains(h.bounds, b) && i.contains(h.vertices, b)) { c.push(e); break } } } return c } }() }, { "../factory/Bodies": 21, "../geometry/Bounds": 24, "../geometry/Vector": 26, "../geometry/Vertices": 27, "./SAT": 11 }], 10: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../geometry/Vertices"), f = a("../geometry/Vector"), g = a("../core/Common"), h = a("../geometry/Bounds"); !function () { d._restingThresh = 4, d._positionDampen = .9, d._positionWarming = .8, d._frictionNormalMultiplier = 5, d.preSolvePosition = function (a) { var b, c, d; for (b = 0; b < a.length; b++)c = a[b], c.isActive && (d = c.activeContacts.length, c.collision.parentA.totalContacts += d, c.collision.parentB.totalContacts += d) }, d.solvePosition = function (a, b) { var c, e, g, h, i, j, k, l, m, n = f._temp[0], o = f._temp[1], p = f._temp[2], q = f._temp[3]; for (c = 0; c < a.length; c++)e = a[c], e.isActive && (g = e.collision, h = g.parentA, i = g.parentB, j = g.normal, k = f.sub(f.add(i.positionImpulse, i.position, n), f.add(h.positionImpulse, f.sub(i.position, g.penetration, o), p), q), e.separation = f.dot(j, k)); for (c = 0; c < a.length; c++)e = a[c], !e.isActive || e.separation < 0 || (g = e.collision, h = g.parentA, i = g.parentB, j = g.normal, m = (e.separation - e.slop) * b, (h.isStatic || i.isStatic) && (m *= 2), h.isStatic || h.isSleeping || (l = d._positionDampen / h.totalContacts, h.positionImpulse.x += j.x * m * l, h.positionImpulse.y += j.y * m * l), i.isStatic || i.isSleeping || (l = d._positionDampen / i.totalContacts, i.positionImpulse.x -= j.x * m * l, i.positionImpulse.y -= j.y * m * l)) }, d.postSolvePosition = function (a) { for (var b = 0; b < a.length; b++) { var c = a[b]; if (c.totalContacts = 0, 0 !== c.positionImpulse.x || 0 !== c.positionImpulse.y) { for (var g = 0; g < c.parts.length; g++) { var i = c.parts[g]; e.translate(i.vertices, c.positionImpulse), h.update(i.bounds, i.vertices, c.velocity), i.position.x += c.positionImpulse.x, i.position.y += c.positionImpulse.y } c.positionPrev.x += c.positionImpulse.x, c.positionPrev.y += c.positionImpulse.y, f.dot(c.positionImpulse, c.velocity) < 0 ? (c.positionImpulse.x = 0, c.positionImpulse.y = 0) : (c.positionImpulse.x *= d._positionWarming, c.positionImpulse.y *= d._positionWarming) } } }, d.preSolveVelocity = function (a) { var b, c, d, e, g, h, i, j, k, l, m, n, o, p, q = f._temp[0], r = f._temp[1]; for (b = 0; b < a.length; b++)if (d = a[b], d.isActive) for (e = d.activeContacts, g = d.collision, h = g.parentA, i = g.parentB, j = g.normal, k = g.tangent, c = 0; c < e.length; c++)l = e[c], m = l.vertex, n = l.normalImpulse, o = l.tangentImpulse, (0 !== n || 0 !== o) && (q.x = j.x * n + k.x * o, q.y = j.y * n + k.y * o, h.isStatic || h.isSleeping || (p = f.sub(m, h.position, r), h.positionPrev.x += q.x * h.inverseMass, h.positionPrev.y += q.y * h.inverseMass, h.anglePrev += f.cross(p, q) * h.inverseInertia), i.isStatic || i.isSleeping || (p = f.sub(m, i.position, r), i.positionPrev.x -= q.x * i.inverseMass, i.positionPrev.y -= q.y * i.inverseMass, i.anglePrev -= f.cross(p, q) * i.inverseInertia)) }, d.solveVelocity = function (a, b) { for (var c = b * b, e = f._temp[0], h = f._temp[1], i = f._temp[2], j = f._temp[3], k = f._temp[4], l = f._temp[5], m = 0; m < a.length; m++) { var n = a[m]; if (n.isActive) { var o = n.collision, p = o.parentA, q = o.parentB, r = o.normal, s = o.tangent, t = n.activeContacts, u = 1 / t.length; p.velocity.x = p.position.x - p.positionPrev.x, p.velocity.y = p.position.y - p.positionPrev.y, q.velocity.x = q.position.x - q.positionPrev.x, q.velocity.y = q.position.y - q.positionPrev.y, p.angularVelocity = p.angle - p.anglePrev, q.angularVelocity = q.angle - q.anglePrev; for (var v = 0; v < t.length; v++) { var w = t[v], x = w.vertex, y = f.sub(x, p.position, h), z = f.sub(x, q.position, i), A = f.add(p.velocity, f.mult(f.perp(y), p.angularVelocity), j), B = f.add(q.velocity, f.mult(f.perp(z), q.angularVelocity), k), C = f.sub(A, B, l), D = f.dot(r, C), E = f.dot(s, C), F = Math.abs(E), G = g.sign(E), H = (1 + n.restitution) * D, I = g.clamp(n.separation + D, 0, 1) * d._frictionNormalMultiplier, J = E, K = 1 / 0; F > n.friction * n.frictionStatic * I * c && (J = n.friction * G * c, K = F); var L = f.cross(y, r), M = f.cross(z, r), N = p.inverseMass + q.inverseMass + p.inverseInertia * L * L + q.inverseInertia * M * M; if (H *= u / N, J *= u / (1 + N), 0 > D && D * D > d._restingThresh * c) w.normalImpulse = 0, w.tangentImpulse = 0; else { var O = w.normalImpulse; w.normalImpulse = Math.min(w.normalImpulse + H, 0), H = w.normalImpulse - O; var P = w.tangentImpulse; w.tangentImpulse = g.clamp(w.tangentImpulse + J, -K, K), J = w.tangentImpulse - P } e.x = r.x * H + s.x * J, e.y = r.y * H + s.y * J, p.isStatic || p.isSleeping || (p.positionPrev.x += e.x * p.inverseMass, p.positionPrev.y += e.y * p.inverseMass, p.anglePrev += f.cross(y, e) * p.inverseInertia), q.isStatic || q.isSleeping || (q.positionPrev.x -= e.x * q.inverseMass, q.positionPrev.y -= e.y * q.inverseMass, q.anglePrev -= f.cross(z, e) * q.inverseInertia) } } } } }() }, { "../core/Common": 14, "../geometry/Bounds": 24, "../geometry/Vector": 26, "../geometry/Vertices": 27 }], 11: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../geometry/Vertices"), f = a("../geometry/Vector"); !function () { d.collides = function (b, d, g) { var h, i, j, k, l = g, m = !1; if (l) { var n = b.parent, o = d.parent, p = n.speed * n.speed + n.angularSpeed * n.angularSpeed + o.speed * o.speed + o.angularSpeed * o.angularSpeed; m = l && l.collided && .2 > p, k = l } else k = { collided: !1, bodyA: b, bodyB: d }; if (l && m) { var q = k.axisBody, r = q === b ? d : b, s = [q.axes[l.axisNumber]]; if (j = a(q.vertices, r.vertices, s), k.reused = !0, j.overlap <= 0) return k.collided = !1, k } else { if (h = a(b.vertices, d.vertices, b.axes), h.overlap <= 0) return k.collided = !1, k; if (i = a(d.vertices, b.vertices, d.axes), i.overlap <= 0) return k.collided = !1, k; h.overlap < i.overlap ? (j = h, k.axisBody = b) : (j = i, k.axisBody = d), k.axisNumber = j.axisNumber } k.bodyA = b.id < d.id ? b : d, k.bodyB = b.id < d.id ? d : b, k.collided = !0, k.normal = j.axis, k.depth = j.overlap, k.parentA = k.bodyA.parent, k.parentB = k.bodyB.parent, b = k.bodyA, d = k.bodyB, f.dot(k.normal, f.sub(d.position, b.position)) > 0 && (k.normal = f.neg(k.normal)), k.tangent = f.perp(k.normal), k.penetration = { x: k.normal.x * k.depth, y: k.normal.y * k.depth }; var t = c(b, d, k.normal), u = k.supports || []; if (u.length = 0, e.contains(b.vertices, t[0]) && u.push(t[0]), e.contains(b.vertices, t[1]) && u.push(t[1]), u.length < 2) { var v = c(d, b, f.neg(k.normal)); e.contains(d.vertices, v[0]) && u.push(v[0]), u.length < 2 && e.contains(d.vertices, v[1]) && u.push(v[1]) } return u.length < 1 && (u = [t[0]]), k.supports = u, k }; var a = function (a, c, d) { for (var e, g, h = f._temp[0], i = f._temp[1], j = { overlap: Number.MAX_VALUE }, k = 0; k < d.length; k++) { if (g = d[k], b(h, a, g), b(i, c, g), e = Math.min(h.max - i.min, i.max - h.min), 0 >= e) return j.overlap = e, j; e < j.overlap && (j.overlap = e, j.axis = g, j.axisNumber = k) } return j }, b = function (a, b, c) { for (var d = f.dot(b[0], c), e = d, g = 1; g < b.length; g += 1) { var h = f.dot(b[g], c); h > e ? e = h : d > h && (d = h) } a.min = d, a.max = e }, c = function (a, b, c) { for (var d, e, g, h, i = Number.MAX_VALUE, j = f._temp[0], k = b.vertices, l = a.position, m = 0; m < k.length; m++)e = k[m], j.x = e.x - l.x, j.y = e.y - l.y, d = -f.dot(c, j), i > d && (i = d, g = e); var n = g.index - 1 >= 0 ? g.index - 1 : k.length - 1; e = k[n], j.x = e.x - l.x, j.y = e.y - l.y, i = -f.dot(c, j), h = e; var o = (g.index + 1) % k.length; return e = k[o], j.x = e.x - l.x, j.y = e.y - l.y, d = -f.dot(c, j), i > d && (h = e), [g, h] } }() }, { "../geometry/Vector": 26, "../geometry/Vertices": 27 }], 12: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../geometry/Vertices"), f = a("../geometry/Vector"), g = a("../core/Sleeping"), h = a("../geometry/Bounds"), i = a("../geometry/Axes"), j = a("../core/Common"); !function () { var a = 1e-6, b = .001; d.create = function (b) { var c = b; c.bodyA && !c.pointA && (c.pointA = { x: 0, y: 0 }), c.bodyB && !c.pointB && (c.pointB = { x: 0, y: 0 }); var d = c.bodyA ? f.add(c.bodyA.position, c.pointA) : c.pointA, e = c.bodyB ? f.add(c.bodyB.position, c.pointB) : c.pointB, g = f.magnitude(f.sub(d, e)); c.length = c.length || g || a; var h = { visible: !0, lineWidth: 2, strokeStyle: "#666" }; return c.render = j.extend(h, c.render), c.id = c.id || j.nextId(), c.label = c.label || "Constraint", c.type = "constraint", c.stiffness = c.stiffness || 1, c.angularStiffness = c.angularStiffness || 0, c.angleA = c.bodyA ? c.bodyA.angle : c.angleA, c.angleB = c.bodyB ? c.bodyB.angle : c.angleB, c }, d.solveAll = function (a, b) { for (var c = 0; c < a.length; c++)d.solve(a[c], b) }, d.solve = function (c, d) { var e = c.bodyA, h = c.bodyB, i = c.pointA, k = c.pointB; e && !e.isStatic && (c.pointA = f.rotate(i, e.angle - c.angleA), c.angleA = e.angle), h && !h.isStatic && (c.pointB = f.rotate(k, h.angle - c.angleB), c.angleB = h.angle); var l = i, m = k; if (e && (l = f.add(e.position, i)), h && (m = f.add(h.position, k)), l && m) { var n = f.sub(l, m), o = f.magnitude(n); 0 === o && (o = a); var p = (o - c.length) / o, q = f.div(n, o), r = f.mult(n, .5 * p * c.stiffness * d * d); if (!(Math.abs(1 - o / c.length) < b * d)) { var s, t, u, v, w, x, y, z; e && !e.isStatic ? (u = { x: l.x - e.position.x + r.x, y: l.y - e.position.y + r.y }, e.velocity.x = e.position.x - e.positionPrev.x, e.velocity.y = e.position.y - e.positionPrev.y, e.angularVelocity = e.angle - e.anglePrev, s = f.add(e.velocity, f.mult(f.perp(u), e.angularVelocity)), w = f.dot(u, q), y = e.inverseMass + e.inverseInertia * w * w) : (s = { x: 0, y: 0 }, y = e ? e.inverseMass : 0), h && !h.isStatic ? (v = { x: m.x - h.position.x - r.x, y: m.y - h.position.y - r.y }, h.velocity.x = h.position.x - h.positionPrev.x, h.velocity.y = h.position.y - h.positionPrev.y, h.angularVelocity = h.angle - h.anglePrev, t = f.add(h.velocity, f.mult(f.perp(v), h.angularVelocity)), x = f.dot(v, q), z = h.inverseMass + h.inverseInertia * x * x) : (t = { x: 0, y: 0 }, z = h ? h.inverseMass : 0); var A = f.sub(t, s), B = f.dot(q, A) / (y + z); B > 0 && (B = 0); var C, D = { x: q.x * B, y: q.y * B }; e && !e.isStatic && (C = f.cross(u, D) * e.inverseInertia * (1 - c.angularStiffness), g.set(e, !1), C = j.clamp(C, -.01, .01), e.constraintImpulse.x -= r.x, e.constraintImpulse.y -= r.y, e.constraintImpulse.angle += C, e.position.x -= r.x, e.position.y -= r.y, e.angle += C), h && !h.isStatic && (C = f.cross(v, D) * h.inverseInertia * (1 - c.angularStiffness), g.set(h, !1), C = j.clamp(C, -.01, .01), h.constraintImpulse.x += r.x, h.constraintImpulse.y += r.y, h.constraintImpulse.angle -= C, h.position.x += r.x, h.position.y += r.y, h.angle -= C) } } }, d.postSolveAll = function (a) { for (var b = 0; b < a.length; b++) { for (var c = a[b], d = c.constraintImpulse, g = 0; g < c.parts.length; g++) { var j = c.parts[g]; e.translate(j.vertices, d), g > 0 && (j.position.x += d.x, j.position.y += d.y), 0 !== d.angle && (e.rotate(j.vertices, d.angle, c.position), i.rotate(j.axes, d.angle), g > 0 && f.rotateAbout(j.position, d.angle, c.position, j.position)), h.update(j.bounds, j.vertices) } d.angle = 0, d.x = 0, d.y = 0 } } }() }, { "../core/Common": 14, "../core/Sleeping": 20, "../geometry/Axes": 23, "../geometry/Bounds": 24, "../geometry/Vector": 26, "../geometry/Vertices": 27 }], 13: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../geometry/Vertices"), f = a("../core/Sleeping"), g = a("../core/Mouse"), h = a("../core/Events"), i = a("../collision/Detector"), j = a("./Constraint"), k = a("../body/Composite"), l = a("../core/Common"), m = a("../geometry/Bounds"); !function () { d.create = function (b, c) { var e = (b ? b.mouse : null) || (c ? c.mouse : null); !e && b && b.render && b.render.canvas ? e = g.create(b.render.canvas) : (e = g.create(), l.log("MouseConstraint.create: options.mouse was undefined, engine.render.canvas was undefined, may not function as expected", "warn")); var f = j.create({ label: "Mouse Constraint", pointA: e.position, pointB: { x: 0, y: 0 }, length: .01, stiffness: .1, angularStiffness: 1, render: { strokeStyle: "#90EE90", lineWidth: 3 } }), i = { type: "mouseConstraint", mouse: e, body: null, constraint: f, collisionFilter: { category: 1, mask: 4294967295, group: 0 } }, m = l.extend(i, c); return h.on(b, "tick", function () { var c = k.allBodies(b.world); d.update(m, c), a(m) }), m }, d.update = function (a, b) { var c = a.mouse, d = a.constraint, g = a.body; if (0 === c.button) { if (d.bodyB) f.set(d.bodyB, !1), d.pointA = c.position; else for (var j = 0; j < b.length; j++)if (g = b[j], m.contains(g.bounds, c.position) && i.canCollide(g.collisionFilter, a.collisionFilter)) for (var k = g.parts.length > 1 ? 1 : 0; k < g.parts.length; k++) { var l = g.parts[k]; if (e.contains(l.vertices, c.position)) { d.pointA = c.position, d.bodyB = a.body = g, d.pointB = { x: c.position.x - g.position.x, y: c.position.y - g.position.y }, d.angleB = g.angle, f.set(g, !1), h.trigger(a, "startdrag", { mouse: c, body: g }); break } } } else d.bodyB = a.body = null, d.pointB = null, g && h.trigger(a, "enddrag", { mouse: c, body: g }) }; var a = function (a) { var b = a.mouse, c = b.sourceEvents; c.mousemove && h.trigger(a, "mousemove", { mouse: b }), c.mousedown && h.trigger(a, "mousedown", { mouse: b }), c.mouseup && h.trigger(a, "mouseup", { mouse: b }), g.clearSourceEvents(b) } }() }, { "../body/Composite": 2, "../collision/Detector": 5, "../core/Common": 14, "../core/Events": 16, "../core/Mouse": 18, "../core/Sleeping": 20, "../geometry/Bounds": 24, "../geometry/Vertices": 27, "./Constraint": 12 }], 14: [function (a, b, c) {
      var d = {}; b.exports = d, function () {
      d._nextId = 0, d._seed = 0, d.extend = function (a, b) { var c, e, f; "boolean" == typeof b ? (c = 2, f = b) : (c = 1, f = !0), e = Array.prototype.slice.call(arguments, c); for (var g = 0; g < e.length; g++) { var h = e[g]; if (h) for (var i in h) f && h[i] && h[i].constructor === Object ? a[i] && a[i].constructor !== Object ? a[i] = h[i] : (a[i] = a[i] || {}, d.extend(a[i], f, h[i])) : a[i] = h[i] } return a }, d.clone = function (a, b) { return d.extend({}, b, a) }, d.keys = function (a) { if (Object.keys) return Object.keys(a); var b = []; for (var c in a) b.push(c); return b }, d.values = function (a) { var b = []; if (Object.keys) { for (var c = Object.keys(a), d = 0; d < c.length; d++)b.push(a[c[d]]); return b } for (var e in a) b.push(a[e]); return b }, d.shadeColor = function (a, b) { var c = parseInt(a.slice(1), 16), d = Math.round(2.55 * b), e = (c >> 16) + d, f = (c >> 8 & 255) + d, g = (255 & c) + d; return "#" + (16777216 + 65536 * (255 > e ? 1 > e ? 0 : e : 255) + 256 * (255 > f ? 1 > f ? 0 : f : 255) + (255 > g ? 1 > g ? 0 : g : 255)).toString(16).slice(1) }, d.shuffle = function (a) { for (var b = a.length - 1; b > 0; b--) { var c = Math.floor(d.random() * (b + 1)), e = a[b]; a[b] = a[c], a[c] = e } return a }, d.choose = function (a) { return a[Math.floor(d.random() * a.length)] }, d.isElement = function (a) { try { return a instanceof HTMLElement } catch (b) { return "object" == typeof a && 1 === a.nodeType && "object" == typeof a.style && "object" == typeof a.ownerDocument } }, d.isArray = function (a) { return "[object Array]" === Object.prototype.toString.call(a) }, d.clamp = function (a, b, c) { return b > a ? b : a > c ? c : a }, d.sign = function (a) { return 0 > a ? -1 : 1 }, d.now = function () { var a = window.performance || {}; return a.now = function () { return a.now || a.webkitNow || a.msNow || a.oNow || a.mozNow || function () { return +new Date } }(), a.now() }, d.random = function (b, c) { return b = "undefined" != typeof b ? b : 0, c = "undefined" != typeof c ? c : 1, b + a() * (c - b) }, d.colorToNumber = function (a) {
        return a = a.replace("#", ""), 3 == a.length && (a = a.charAt(0) + a.charAt(0) + a.charAt(1) + a.charAt(1) + a.charAt(2) + a.charAt(2)),
          parseInt(a, 16)
      }, d.log = function (a, b) { if (console && console.log && console.warn) switch (b) { case "warn": break; case "error": } }, d.nextId = function () { return d._nextId++ }, d.indexOf = function (a, b) { if (a.indexOf) return a.indexOf(b); for (var c = 0; c < a.length; c++)if (a[c] === b) return c; return -1 }; var a = function () { return d._seed = (9301 * d._seed + 49297) % 233280, d._seed / 233280 }
      }()
    }, {}], 15: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../body/World"), f = a("./Sleeping"), g = a("../collision/Resolver"), h = a("../render/Render"), i = a("../collision/Pairs"), j = (a("./Metrics"), a("../collision/Grid")), k = a("./Events"), l = a("../body/Composite"), m = a("../constraint/Constraint"), n = a("./Common"), o = a("../body/Body"); !function () { d.create = function (a, b) { b = n.isElement(a) ? b : a, a = n.isElement(a) ? a : null; var c = { positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], timing: { timestamp: 0, timeScale: 1 }, broadphase: { controller: j } }, d = n.extend(c, b); if (a || d.render) { var f = { element: a, controller: h }; d.render = n.extend(f, d.render) } return d.render && d.render.controller && (d.render = d.render.controller.create(d.render)), d.world = e.create(d.world), d.pairs = i.create(), d.broadphase = d.broadphase.controller.create(d.broadphase), d.metrics = d.metrics || { extended: !1 }, d }, d.update = function (d, e, h) { h = "undefined" != typeof h ? h : 1; var j, n = d.world, o = d.timing, p = d.broadphase, q = []; o.timestamp += e * o.timeScale; var r = { timestamp: o.timestamp }; k.trigger(d, "beforeUpdate", r); var s = l.allBodies(n), t = l.allConstraints(n); for (d.enableSleeping && f.update(s, o.timeScale), b(s, n.gravity), c(s, e, o.timeScale, h, n.bounds), j = 0; j < d.constraintIterations; j++)m.solveAll(t, o.timeScale); m.postSolveAll(s), p.controller ? (n.isModified && p.controller.clear(p), p.controller.update(p, s, d, n.isModified), q = p.pairsList) : q = s; var u = p.detector(q, d), v = d.pairs, w = o.timestamp; for (i.update(v, u, w), i.removeOld(v, w), d.enableSleeping && f.afterCollisions(v.list, o.timeScale), v.collisionStart.length > 0 && k.trigger(d, "collisionStart", { pairs: v.collisionStart }), g.preSolvePosition(v.list), j = 0; j < d.positionIterations; j++)g.solvePosition(v.list, o.timeScale); for (g.postSolvePosition(s), g.preSolveVelocity(v.list), j = 0; j < d.velocityIterations; j++)g.solveVelocity(v.list, o.timeScale); return v.collisionActive.length > 0 && k.trigger(d, "collisionActive", { pairs: v.collisionActive }), v.collisionEnd.length > 0 && k.trigger(d, "collisionEnd", { pairs: v.collisionEnd }), a(s), n.isModified && l.setModified(n, !1, !1, !0), k.trigger(d, "afterUpdate", r), d }, d.merge = function (a, b) { if (n.extend(a, b), b.world) { a.world = b.world, d.clear(a); for (var c = l.allBodies(a.world), e = 0; e < c.length; e++) { var g = c[e]; f.set(g, !1), g.id = n.nextId() } } }, d.clear = function (a) { var b = a.world; i.clear(a.pairs); var c = a.broadphase; if (c.controller) { var d = l.allBodies(b); c.controller.clear(c), c.controller.update(c, d, a, !0) } }; var a = function (a) { for (var b = 0; b < a.length; b++) { var c = a[b]; c.force.x = 0, c.force.y = 0, c.torque = 0 } }, b = function (a, b) { for (var c = 0; c < a.length; c++) { var d = a[c]; d.isStatic || d.isSleeping || (d.force.y += d.mass * b.y * .001, d.force.x += d.mass * b.x * .001) } }, c = function (a, b, c, d, e) { for (var f = 0; f < a.length; f++) { var g = a[f]; g.isStatic || g.isSleeping || o.update(g, b, c, d) } } }() }, { "../body/Body": 1, "../body/Composite": 2, "../body/World": 3, "../collision/Grid": 6, "../collision/Pairs": 8, "../collision/Resolver": 10, "../constraint/Constraint": 12, "../render/Render": 29, "./Common": 14, "./Events": 16, "./Metrics": 17, "./Sleeping": 20 }], 16: [function (a, b, c) { var d = {}; b.exports = d; var e = a("./Common"); !function () { d.on = function (a, b, c) { for (var d, e = b.split(" "), f = 0; f < e.length; f++)d = e[f], a.events = a.events || {}, a.events[d] = a.events[d] || [], a.events[d].push(c); return c }, d.off = function (a, b, c) { if (!b) return void (a.events = {}); "function" == typeof b && (c = b, b = e.keys(a.events).join(" ")); for (var d = b.split(" "), f = 0; f < d.length; f++) { var g = a.events[d[f]], h = []; if (c && g) for (var i = 0; i < g.length; i++)g[i] !== c && h.push(g[i]); a.events[d[f]] = h } }, d.trigger = function (a, b, c) { var d, f, g, h; if (a.events) { c || (c = {}), d = b.split(" "); for (var i = 0; i < d.length; i++)if (f = d[i], g = a.events[f]) { h = e.clone(c, !1), h.name = f, h.source = a; for (var j = 0; j < g.length; j++)g[j].apply(a, [h]) } } } }() }, { "./Common": 14 }], 17: [function (a, b, c) { }, { "../body/Composite": 2, "./Common": 14 }], 18: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../core/Common"); !function () { d.create = function (b) { var c = {}; return b || e.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), c.element = b || document.body, c.absolute = { x: 0, y: 0 }, c.position = { x: 0, y: 0 }, c.mousedownPosition = { x: 0, y: 0 }, c.mouseupPosition = { x: 0, y: 0 }, c.offset = { x: 0, y: 0 }, c.scale = { x: 1, y: 1 }, c.wheelDelta = 0, c.button = -1, c.pixelRatio = c.element.getAttribute("data-pixel-ratio") || 1, c.sourceEvents = { mousemove: null, mousedown: null, mouseup: null, mousewheel: null }, c.mousemove = function (b) { var d = a(b, c.element, c.pixelRatio), e = b.changedTouches; e && (c.button = 0, b.preventDefault()), c.absolute.x = d.x, c.absolute.y = d.y, c.position.x = c.absolute.x * c.scale.x + c.offset.x, c.position.y = c.absolute.y * c.scale.y + c.offset.y, c.sourceEvents.mousemove = b }, c.mousedown = function (b) { var d = a(b, c.element, c.pixelRatio), e = b.changedTouches; e ? (c.button = 0, b.preventDefault()) : c.button = b.button, c.absolute.x = d.x, c.absolute.y = d.y, c.position.x = c.absolute.x * c.scale.x + c.offset.x, c.position.y = c.absolute.y * c.scale.y + c.offset.y, c.mousedownPosition.x = c.position.x, c.mousedownPosition.y = c.position.y, c.sourceEvents.mousedown = b }, c.mouseup = function (b) { var d = a(b, c.element, c.pixelRatio), e = b.changedTouches; e && b.preventDefault(), c.button = -1, c.absolute.x = d.x, c.absolute.y = d.y, c.position.x = c.absolute.x * c.scale.x + c.offset.x, c.position.y = c.absolute.y * c.scale.y + c.offset.y, c.mouseupPosition.x = c.position.x, c.mouseupPosition.y = c.position.y, c.sourceEvents.mouseup = b }, c.mousewheel = function (a) { c.wheelDelta = Math.max(-1, Math.min(1, a.wheelDelta || -a.detail)), a.preventDefault() }, d.setElement(c, c.element), c }, d.setElement = function (a, b) { a.element = b, b.addEventListener("mousemove", a.mousemove), b.addEventListener("mousedown", a.mousedown), b.addEventListener("mouseup", a.mouseup), b.addEventListener("mousewheel", a.mousewheel), b.addEventListener("DOMMouseScroll", a.mousewheel), b.addEventListener("touchmove", a.mousemove), b.addEventListener("touchstart", a.mousedown), b.addEventListener("touchend", a.mouseup) }, d.clearSourceEvents = function (a) { a.sourceEvents.mousemove = null, a.sourceEvents.mousedown = null, a.sourceEvents.mouseup = null, a.sourceEvents.mousewheel = null, a.wheelDelta = 0 }, d.setOffset = function (a, b) { a.offset.x = b.x, a.offset.y = b.y, a.position.x = a.absolute.x * a.scale.x + a.offset.x, a.position.y = a.absolute.y * a.scale.y + a.offset.y }, d.setScale = function (a, b) { a.scale.x = b.x, a.scale.y = b.y, a.position.x = a.absolute.x * a.scale.x + a.offset.x, a.position.y = a.absolute.y * a.scale.y + a.offset.y }; var a = function (a, b, c) { var d, e, f = b.getBoundingClientRect(), g = document.documentElement || document.body.parentNode || document.body, h = void 0 !== window.pageXOffset ? window.pageXOffset : g.scrollLeft, i = void 0 !== window.pageYOffset ? window.pageYOffset : g.scrollTop, j = a.changedTouches; return j ? (d = j[0].pageX - f.left - h, e = j[0].pageY - f.top - i) : (d = a.pageX - f.left - h, e = a.pageY - f.top - i), { x: d / (b.clientWidth / b.width * c), y: e / (b.clientHeight / b.height * c) } } }() }, { "../core/Common": 14 }], 19: [function (a, b, c) { var d = {}; b.exports = d; var e = a("./Events"), f = a("./Engine"), g = a("./Common"); !function () { var a, b; "undefined" != typeof window && (a = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (a) { window.setTimeout(function () { a(g.now()) }, 1e3 / 60) }, b = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), d.create = function (a) { var b = { fps: 60, correction: 1, deltaSampleSize: 60, counterTimestamp: 0, frameCounter: 0, deltaHistory: [], timePrev: null, timeScalePrev: 1, frameRequestId: null, isFixed: !1, enabled: !0 }, c = g.extend(b, a); return c.delta = c.delta || 1e3 / c.fps, c.deltaMin = c.deltaMin || 1e3 / c.fps, c.deltaMax = c.deltaMax || 1e3 / (.5 * c.fps), c.fps = 1e3 / c.delta, c }, d.run = function (b, c) { return "undefined" != typeof b.positionIterations && (c = b, b = d.create()), function e(f) { b.frameRequestId = a(e), f && b.enabled && d.tick(b, c, f) }(), b }, d.tick = function (a, b, c) { var d, g = b.timing, h = 1, i = { timestamp: g.timestamp }; e.trigger(a, "beforeTick", i), e.trigger(b, "beforeTick", i), a.isFixed ? d = a.delta : (d = c - a.timePrev || a.delta, a.timePrev = c, a.deltaHistory.push(d), a.deltaHistory = a.deltaHistory.slice(-a.deltaSampleSize), d = Math.min.apply(null, a.deltaHistory), d = d < a.deltaMin ? a.deltaMin : d, d = d > a.deltaMax ? a.deltaMax : d, h = d / a.delta, a.delta = d), 0 !== a.timeScalePrev && (h *= g.timeScale / a.timeScalePrev), 0 === g.timeScale && (h = 0), a.timeScalePrev = g.timeScale, a.correction = h, a.frameCounter += 1, c - a.counterTimestamp >= 1e3 && (a.fps = a.frameCounter * ((c - a.counterTimestamp) / 1e3), a.counterTimestamp = c, a.frameCounter = 0), e.trigger(a, "tick", i), e.trigger(b, "tick", i), b.world.isModified && b.render && b.render.controller && b.render.controller.clear && b.render.controller.clear(b.render), e.trigger(a, "beforeUpdate", i), f.update(b, d, h), e.trigger(a, "afterUpdate", i), b.render && b.render.controller && (e.trigger(a, "beforeRender", i), e.trigger(b, "beforeRender", i), b.render.controller.world(b), e.trigger(a, "afterRender", i), e.trigger(b, "afterRender", i)), e.trigger(a, "afterTick", i), e.trigger(b, "afterTick", i) }, d.stop = function (a) { b(a.frameRequestId) } }() }, { "./Common": 14, "./Engine": 15, "./Events": 16 }], 20: [function (a, b, c) { var d = {}; b.exports = d; var e = a("./Events"); !function () { d._motionWakeThreshold = .18, d._motionSleepThreshold = .08, d._minBias = .9, d.update = function (a, b) { for (var c = b * b * b, e = 0; e < a.length; e++) { var f = a[e], g = f.speed * f.speed + f.angularSpeed * f.angularSpeed; if (0 === f.force.x && 0 === f.force.y) { var h = Math.min(f.motion, g), i = Math.max(f.motion, g); f.motion = d._minBias * h + (1 - d._minBias) * i, f.sleepThreshold > 0 && f.motion < d._motionSleepThreshold * c ? (f.sleepCounter += 1, f.sleepCounter >= f.sleepThreshold && d.set(f, !0)) : f.sleepCounter > 0 && (f.sleepCounter -= 1) } else d.set(f, !1) } }, d.afterCollisions = function (a, b) { for (var c = b * b * b, e = 0; e < a.length; e++) { var f = a[e]; if (f.isActive) { var g = f.collision, h = g.bodyA.parent, i = g.bodyB.parent; if (!(h.isSleeping && i.isSleeping || h.isStatic || i.isStatic) && (h.isSleeping || i.isSleeping)) { var j = h.isSleeping && !h.isStatic ? h : i, k = j === h ? i : h; !j.isStatic && k.motion > d._motionWakeThreshold * c && d.set(j, !1) } } } }, d.set = function (a, b) { var c = a.isSleeping; b ? (a.isSleeping = !0, a.sleepCounter = a.sleepThreshold, a.positionImpulse.x = 0, a.positionImpulse.y = 0, a.positionPrev.x = a.position.x, a.positionPrev.y = a.position.y, a.anglePrev = a.angle, a.speed = 0, a.angularSpeed = 0, a.motion = 0, c || e.trigger(a, "sleepStart")) : (a.isSleeping = !1, a.sleepCounter = 0, c && e.trigger(a, "sleepEnd")) } }() }, { "./Events": 16 }], 21: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../geometry/Vertices"), f = a("../core/Common"), g = a("../body/Body"), h = a("../geometry/Bounds"), i = a("../geometry/Vector"); !function () { d.rectangle = function (a, b, c, d, h) { h = h || {}; var i = { label: "Rectangle Body", position: { x: a, y: b }, vertices: e.fromPath("L 0 0 L " + c + " 0 L " + c + " " + d + " L 0 " + d) }; if (h.chamfer) { var j = h.chamfer; i.vertices = e.chamfer(i.vertices, j.radius, j.quality, j.qualityMin, j.qualityMax), delete h.chamfer } return g.create(f.extend({}, i, h)) }, d.trapezoid = function (a, b, c, d, h, i) { i = i || {}, h *= .5; var j = (1 - 2 * h) * c, k = c * h, l = k + j, m = l + k, n = { label: "Trapezoid Body", position: { x: a, y: b }, vertices: e.fromPath("L 0 0 L " + k + " " + -d + " L " + l + " " + -d + " L " + m + " 0") }; if (i.chamfer) { var o = i.chamfer; n.vertices = e.chamfer(n.vertices, o.radius, o.quality, o.qualityMin, o.qualityMax), delete i.chamfer } return g.create(f.extend({}, n, i)) }, d.circle = function (a, b, c, e, f) { e = e || {}, e.label = "Circle Body", f = f || 25; var g = Math.ceil(Math.max(10, Math.min(f, c))); return g % 2 === 1 && (g += 1), e.circleRadius = c, d.polygon(a, b, g, c, e) }, d.polygon = function (a, b, c, h, i) { if (i = i || {}, 3 > c) return d.circle(a, b, h, i); for (var j = 2 * Math.PI / c, k = "", l = .5 * j, m = 0; c > m; m += 1) { var n = l + m * j, o = Math.cos(n) * h, p = Math.sin(n) * h; k += "L " + o.toFixed(3) + " " + p.toFixed(3) + " " } var q = { label: "Polygon Body", position: { x: a, y: b }, vertices: e.fromPath(k) }; if (i.chamfer) { var r = i.chamfer; q.vertices = e.chamfer(q.vertices, r.radius, r.quality, r.qualityMin, r.qualityMax), delete i.chamfer } return g.create(f.extend({}, q, i)) }, d.fromVertices = function (a, b, c, d, j, k, l) { var m, n, o, p, q, r, s, t, u; for (d = d || {}, n = [], j = "undefined" != typeof j ? j : !1, k = "undefined" != typeof k ? k : .01, l = "undefined" != typeof l ? l : 10, window.decomp || f.log("Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.", "warn"), f.isArray(c[0]) || (c = [c]), t = 0; t < c.length; t += 1)if (p = c[t], o = e.isConvex(p), o || !window.decomp) p = o ? e.clockwiseSort(p) : e.hull(p), n.push({ position: { x: a, y: b }, vertices: p }); else { var v = new decomp.Polygon; for (q = 0; q < p.length; q++)v.vertices.push([p[q].x, p[q].y]); v.makeCCW(), k !== !1 && v.removeCollinearPoints(k); var w = v.quickDecomp(); for (q = 0; q < w.length; q++) { var x = w[q], y = []; for (r = 0; r < x.vertices.length; r++)y.push({ x: x.vertices[r][0], y: x.vertices[r][1] }); l > 0 && e.area(y) < l || n.push({ position: e.centre(y), vertices: y }) } } for (q = 0; q < n.length; q++)n[q] = g.create(f.extend(n[q], d)); if (j) { var z = 5; for (q = 0; q < n.length; q++) { var A = n[q]; for (r = q + 1; r < n.length; r++) { var B = n[r]; if (h.overlaps(A.bounds, B.bounds)) { var C = A.vertices, D = B.vertices; for (s = 0; s < A.vertices.length; s++)for (u = 0; u < B.vertices.length; u++) { var E = i.magnitudeSquared(i.sub(C[(s + 1) % C.length], D[u])), F = i.magnitudeSquared(i.sub(C[s], D[(u + 1) % D.length])); z > E && z > F && (C[s].isInternal = !0, D[u].isInternal = !0) } } } } } return n.length > 1 ? (m = g.create(f.extend({ parts: n.slice(0) }, d)), g.setPosition(m, { x: a, y: b }), m) : n[0] } }() }, { "../body/Body": 1, "../core/Common": 14, "../geometry/Bounds": 24, "../geometry/Vector": 26, "../geometry/Vertices": 27 }], 22: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../body/Composite"), f = a("../constraint/Constraint"), g = a("../core/Common"), h = a("../body/Body"), i = a("./Bodies"); !function () { d.stack = function (a, b, c, d, f, g, i) { for (var j, k = e.create({ label: "Stack" }), l = a, m = b, n = 0, o = 0; d > o; o++) { for (var p = 0, q = 0; c > q; q++) { var r = i(l, m, q, o, j, n); if (r) { var s = r.bounds.max.y - r.bounds.min.y, t = r.bounds.max.x - r.bounds.min.x; s > p && (p = s), h.translate(r, { x: .5 * t, y: .5 * s }), l = r.bounds.max.x + f, e.addBody(k, r), j = r, n += 1 } else l += f } m += p + g, l = a } return k }, d.chain = function (a, b, c, d, h, i) { for (var j = a.bodies, k = 1; k < j.length; k++) { var l = j[k - 1], m = j[k], n = l.bounds.max.y - l.bounds.min.y, o = l.bounds.max.x - l.bounds.min.x, p = m.bounds.max.y - m.bounds.min.y, q = m.bounds.max.x - m.bounds.min.x, r = { bodyA: l, pointA: { x: o * b, y: n * c }, bodyB: m, pointB: { x: q * d, y: p * h } }, s = g.extend(r, i); e.addConstraint(a, f.create(s)) } return a.label += " Chain", a }, d.mesh = function (a, b, c, d, h) { var i, j, k, l, m, n = a.bodies; for (i = 0; c > i; i++) { for (j = 1; b > j; j++)k = n[j - 1 + i * b], l = n[j + i * b], e.addConstraint(a, f.create(g.extend({ bodyA: k, bodyB: l }, h))); if (i > 0) for (j = 0; b > j; j++)k = n[j + (i - 1) * b], l = n[j + i * b], e.addConstraint(a, f.create(g.extend({ bodyA: k, bodyB: l }, h))), d && j > 0 && (m = n[j - 1 + (i - 1) * b], e.addConstraint(a, f.create(g.extend({ bodyA: m, bodyB: l }, h)))), d && b - 1 > j && (m = n[j + 1 + (i - 1) * b], e.addConstraint(a, f.create(g.extend({ bodyA: m, bodyB: l }, h)))) } return a.label += " Mesh", a }, d.pyramid = function (a, b, c, e, f, g, i) { return d.stack(a, b, c, e, f, g, function (b, d, g, j, k, l) { var m = Math.min(e, Math.ceil(c / 2)), n = k ? k.bounds.max.x - k.bounds.min.x : 0; if (!(j > m)) { j = m - j; var o = j, p = c - 1 - j; if (!(o > g || g > p)) { 1 === l && h.translate(k, { x: (g + (c % 2 === 1 ? 1 : -1)) * n, y: 0 }); var q = k ? g * n : 0; return i(a + q + g * f, d, g, j, k, l) } } }) }, d.newtonsCradle = function (a, b, c, d, g) { for (var h = e.create({ label: "Newtons Cradle" }), j = 0; c > j; j++) { var k = 1.9, l = i.circle(a + j * (d * k), b + g, d, { inertia: 99999, restitution: 1, friction: 0, frictionAir: 1e-4, slop: .01 }), m = f.create({ pointA: { x: a + j * (d * k), y: b }, bodyB: l }); e.addBody(h, l), e.addConstraint(h, m) } return h }, d.car = function (a, b, c, d, g) { var j = h.nextGroup(!0), k = -20, l = .5 * -c + k, m = .5 * c - k, n = 0, o = e.create({ label: "Car" }), p = i.trapezoid(a, b, c, d, .3, { collisionFilter: { group: j }, friction: .01, chamfer: { radius: 10 } }), q = i.circle(a + l, b + n, g, { collisionFilter: { group: j }, restitution: .5, friction: .9, frictionStatic: 10, slop: .5, density: .01 }), r = i.circle(a + m, b + n, g, { collisionFilter: { group: j }, restitution: .5, friction: .9, frictionStatic: 10, slop: .5, density: .01 }), s = f.create({ bodyA: p, pointA: { x: l, y: n }, bodyB: q, stiffness: .5 }), t = f.create({ bodyA: p, pointA: { x: m, y: n }, bodyB: r, stiffness: .5 }); return e.addBody(o, p), e.addBody(o, q), e.addBody(o, r), e.addConstraint(o, s), e.addConstraint(o, t), o }, d.softBody = function (a, b, c, e, f, h, j, k, l, m) { l = g.extend({ inertia: 1 / 0 }, l), m = g.extend({ stiffness: .4 }, m); var n = d.stack(a, b, c, e, f, h, function (a, b) { return i.circle(a, b, k, l) }); return d.mesh(n, c, e, j, m), n.label = "Soft Body", n } }() }, { "../body/Body": 1, "../body/Composite": 2, "../constraint/Constraint": 12, "../core/Common": 14, "./Bodies": 21 }], 23: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../geometry/Vector"), f = a("../core/Common"); !function () { d.fromVertices = function (a) { for (var b = {}, c = 0; c < a.length; c++) { var d = (c + 1) % a.length, g = e.normalise({ x: a[d].y - a[c].y, y: a[c].x - a[d].x }), h = 0 === g.y ? 1 / 0 : g.x / g.y; h = h.toFixed(3).toString(), b[h] = g } return f.values(b) }, d.rotate = function (a, b) { if (0 !== b) for (var c = Math.cos(b), d = Math.sin(b), e = 0; e < a.length; e++) { var f, g = a[e]; f = g.x * c - g.y * d, g.y = g.x * d + g.y * c, g.x = f } } }() }, { "../core/Common": 14, "../geometry/Vector": 26 }], 24: [function (a, b, c) { var d = {}; b.exports = d, function () { d.create = function (a) { var b = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return a && d.update(b, a), b }, d.update = function (a, b, c) { a.min.x = Number.MAX_VALUE, a.max.x = Number.MIN_VALUE, a.min.y = Number.MAX_VALUE, a.max.y = Number.MIN_VALUE; for (var d = 0; d < b.length; d++) { var e = b[d]; e.x > a.max.x && (a.max.x = e.x), e.x < a.min.x && (a.min.x = e.x), e.y > a.max.y && (a.max.y = e.y), e.y < a.min.y && (a.min.y = e.y) } c && (c.x > 0 ? a.max.x += c.x : a.min.x += c.x, c.y > 0 ? a.max.y += c.y : a.min.y += c.y) }, d.contains = function (a, b) { return b.x >= a.min.x && b.x <= a.max.x && b.y >= a.min.y && b.y <= a.max.y }, d.overlaps = function (a, b) { return a.min.x <= b.max.x && a.max.x >= b.min.x && a.max.y >= b.min.y && a.min.y <= b.max.y }, d.translate = function (a, b) { a.min.x += b.x, a.max.x += b.x, a.min.y += b.y, a.max.y += b.y }, d.shift = function (a, b) { var c = a.max.x - a.min.x, d = a.max.y - a.min.y; a.min.x = b.x, a.max.x = b.x + c, a.min.y = b.y, a.max.y = b.y + d } }() }, {}], 25: [function (a, b, c) { var d = {}; b.exports = d; a("../geometry/Bounds"); !function () { d.pathToVertices = function (b, c) { var d, e, f, g, h, i, j, k, l, m, n, o, p = [], q = 0, r = 0, s = 0; c = c || 15; var t = function (a, b, c) { var d = c % 2 === 1 && c > 1; if (!l || a != l.x || b != l.y) { l && d ? (n = l.x, o = l.y) : (n = 0, o = 0); var e = { x: n + a, y: o + b }; (d || !l) && (l = e), p.push(e), r = n + a, s = o + b } }, u = function (a) { var b = a.pathSegTypeAsLetter.toUpperCase(); if ("Z" !== b) { switch (b) { case "M": case "L": case "T": case "C": case "S": case "Q": r = a.x, s = a.y; break; case "H": r = a.x; break; case "V": s = a.y }t(r, s, a.pathSegType) } }; for (a(b), f = b.getTotalLength(), i = [], d = 0; d < b.pathSegList.numberOfItems; d += 1)i.push(b.pathSegList.getItem(d)); for (j = i.concat(); f > q;) { if (m = b.getPathSegAtLength(q), h = i[m], h != k) { for (; j.length && j[0] != h;)u(j.shift()); k = h } switch (h.pathSegTypeAsLetter.toUpperCase()) { case "C": case "T": case "S": case "Q": case "A": g = b.getPointAtLength(q), t(g.x, g.y, 0) }q += c } for (d = 0, e = j.length; e > d; ++d)u(j[d]); return p }; var a = function (a) { for (var b, c, d, e, f, g, h = a.pathSegList, i = 0, j = 0, k = h.numberOfItems, l = 0; k > l; ++l) { var m = h.getItem(l), n = m.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(n)) "x" in m && (i = m.x), "y" in m && (j = m.y); else switch ("x1" in m && (d = i + m.x1), "x2" in m && (f = i + m.x2), "y1" in m && (e = j + m.y1), "y2" in m && (g = j + m.y2), "x" in m && (i += m.x), "y" in m && (j += m.y), n) { case "m": h.replaceItem(a.createSVGPathSegMovetoAbs(i, j), l); break; case "l": h.replaceItem(a.createSVGPathSegLinetoAbs(i, j), l); break; case "h": h.replaceItem(a.createSVGPathSegLinetoHorizontalAbs(i), l); break; case "v": h.replaceItem(a.createSVGPathSegLinetoVerticalAbs(j), l); break; case "c": h.replaceItem(a.createSVGPathSegCurvetoCubicAbs(i, j, d, e, f, g), l); break; case "s": h.replaceItem(a.createSVGPathSegCurvetoCubicSmoothAbs(i, j, f, g), l); break; case "q": h.replaceItem(a.createSVGPathSegCurvetoQuadraticAbs(i, j, d, e), l); break; case "t": h.replaceItem(a.createSVGPathSegCurvetoQuadraticSmoothAbs(i, j), l); break; case "a": h.replaceItem(a.createSVGPathSegArcAbs(i, j, m.r1, m.r2, m.angle, m.largeArcFlag, m.sweepFlag), l); break; case "z": case "Z": i = b, j = c }("M" == n || "m" == n) && (b = i, c = j) } } }() }, { "../geometry/Bounds": 24 }], 26: [function (a, b, c) { var d = {}; b.exports = d, function () { d.create = function (a, b) { return { x: a || 0, y: b || 0 } }, d.clone = function (a) { return { x: a.x, y: a.y } }, d.magnitude = function (a) { return Math.sqrt(a.x * a.x + a.y * a.y) }, d.magnitudeSquared = function (a) { return a.x * a.x + a.y * a.y }, d.rotate = function (a, b) { var c = Math.cos(b), d = Math.sin(b); return { x: a.x * c - a.y * d, y: a.x * d + a.y * c } }, d.rotateAbout = function (a, b, c, d) { var e = Math.cos(b), f = Math.sin(b); d || (d = {}); var g = c.x + ((a.x - c.x) * e - (a.y - c.y) * f); return d.y = c.y + ((a.x - c.x) * f + (a.y - c.y) * e), d.x = g, d }, d.normalise = function (a) { var b = d.magnitude(a); return 0 === b ? { x: 0, y: 0 } : { x: a.x / b, y: a.y / b } }, d.dot = function (a, b) { return a.x * b.x + a.y * b.y }, d.cross = function (a, b) { return a.x * b.y - a.y * b.x }, d.cross3 = function (a, b, c) { return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) }, d.add = function (a, b, c) { return c || (c = {}), c.x = a.x + b.x, c.y = a.y + b.y, c }, d.sub = function (a, b, c) { return c || (c = {}), c.x = a.x - b.x, c.y = a.y - b.y, c }, d.mult = function (a, b) { return { x: a.x * b, y: a.y * b } }, d.div = function (a, b) { return { x: a.x / b, y: a.y / b } }, d.perp = function (a, b) { return b = b === !0 ? -1 : 1, { x: b * -a.y, y: b * a.x } }, d.neg = function (a) { return { x: -a.x, y: -a.y } }, d.angle = function (a, b) { return Math.atan2(b.y - a.y, b.x - a.x) }, d._temp = [d.create(), d.create(), d.create(), d.create(), d.create(), d.create()] }() }, {}], 27: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../geometry/Vector"), f = a("../core/Common"); !function () { d.create = function (a, b) { for (var c = [], d = 0; d < a.length; d++) { var e = a[d], f = { x: e.x, y: e.y, index: d, body: b, isInternal: !1 }; c.push(f) } return c }, d.fromPath = function (a, b) { var c = /L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/gi, e = []; return a.replace(c, function (a, b, c) { e.push({ x: parseFloat(b), y: parseFloat(c) }) }), d.create(e, b) }, d.centre = function (a) { for (var b, c, f, g = d.area(a, !0), h = { x: 0, y: 0 }, i = 0; i < a.length; i++)f = (i + 1) % a.length, b = e.cross(a[i], a[f]), c = e.mult(e.add(a[i], a[f]), b), h = e.add(h, c); return e.div(h, 6 * g) }, d.mean = function (a) { for (var b = { x: 0, y: 0 }, c = 0; c < a.length; c++)b.x += a[c].x, b.y += a[c].y; return e.div(b, a.length) }, d.area = function (a, b) { for (var c = 0, d = a.length - 1, e = 0; e < a.length; e++)c += (a[d].x - a[e].x) * (a[d].y + a[e].y), d = e; return b ? c / 2 : Math.abs(c) / 2 }, d.inertia = function (a, b) { for (var c, d, f = 0, g = 0, h = a, i = 0; i < h.length; i++)d = (i + 1) % h.length, c = Math.abs(e.cross(h[d], h[i])), f += c * (e.dot(h[d], h[d]) + e.dot(h[d], h[i]) + e.dot(h[i], h[i])), g += c; return b / 6 * (f / g) }, d.translate = function (a, b, c) { var d; if (c) for (d = 0; d < a.length; d++)a[d].x += b.x * c, a[d].y += b.y * c; else for (d = 0; d < a.length; d++)a[d].x += b.x, a[d].y += b.y; return a }, d.rotate = function (a, b, c) { if (0 !== b) { for (var d = Math.cos(b), e = Math.sin(b), f = 0; f < a.length; f++) { var g = a[f], h = g.x - c.x, i = g.y - c.y; g.x = c.x + (h * d - i * e), g.y = c.y + (h * e + i * d) } return a } }, d.contains = function (a, b) { for (var c = 0; c < a.length; c++) { var d = a[c], e = a[(c + 1) % a.length]; if ((b.x - d.x) * (e.y - d.y) + (b.y - d.y) * (d.x - e.x) > 0) return !1 } return !0 }, d.scale = function (a, b, c, f) { if (1 === b && 1 === c) return a; f = f || d.centre(a); for (var g, h, i = 0; i < a.length; i++)g = a[i], h = e.sub(g, f), a[i].x = f.x + h.x * b, a[i].y = f.y + h.y * c; return a }, d.chamfer = function (a, b, c, d, g) { b = b || [8], b.length || (b = [b]), c = "undefined" != typeof c ? c : -1, d = d || 2, g = g || 14; for (var h = [], i = 0; i < a.length; i++) { var j = a[i - 1 >= 0 ? i - 1 : a.length - 1], k = a[i], l = a[(i + 1) % a.length], m = b[i < b.length ? i : b.length - 1]; if (0 !== m) { var n = e.normalise({ x: k.y - j.y, y: j.x - k.x }), o = e.normalise({ x: l.y - k.y, y: k.x - l.x }), p = Math.sqrt(2 * Math.pow(m, 2)), q = e.mult(f.clone(n), m), r = e.normalise(e.mult(e.add(n, o), .5)), s = e.sub(k, e.mult(r, p)), t = c; -1 === c && (t = 1.75 * Math.pow(m, .32)), t = f.clamp(t, d, g), t % 2 === 1 && (t += 1); for (var u = Math.acos(e.dot(n, o)), v = u / t, w = 0; t > w; w++)h.push(e.add(e.rotate(q, v * w), s)) } else h.push(k) } return h }, d.clockwiseSort = function (a) { var b = d.mean(a); return a.sort(function (a, c) { return e.angle(b, a) - e.angle(b, c) }), a }, d.isConvex = function (a) { var b, c, d, e, f = 0, g = a.length; if (3 > g) return null; for (b = 0; g > b; b++)if (c = (b + 1) % g, d = (b + 2) % g, e = (a[c].x - a[b].x) * (a[d].y - a[c].y), e -= (a[c].y - a[b].y) * (a[d].x - a[c].x), 0 > e ? f |= 1 : e > 0 && (f |= 2), 3 === f) return !1; return 0 !== f ? !0 : null }, d.hull = function (a) { var b, c, d = [], f = []; for (a = a.slice(0), a.sort(function (a, b) { var c = a.x - b.x; return 0 !== c ? c : a.y - b.y }), c = 0; c < a.length; c++) { for (b = a[c]; f.length >= 2 && e.cross3(f[f.length - 2], f[f.length - 1], b) <= 0;)f.pop(); f.push(b) } for (c = a.length - 1; c >= 0; c--) { for (b = a[c]; d.length >= 2 && e.cross3(d[d.length - 2], d[d.length - 1], b) <= 0;)d.pop(); d.push(b) } return d.pop(), f.pop(), d.concat(f) } }() }, { "../core/Common": 14, "../geometry/Vector": 26 }], 28: [function (a, b, c) { var d = b.exports = {}; d.Body = a("../body/Body"), d.Composite = a("../body/Composite"), d.World = a("../body/World"), d.Contact = a("../collision/Contact"), d.Detector = a("../collision/Detector"), d.Grid = a("../collision/Grid"), d.Pairs = a("../collision/Pairs"), d.Pair = a("../collision/Pair"), d.Query = a("../collision/Query"), d.Resolver = a("../collision/Resolver"), d.SAT = a("../collision/SAT"), d.Constraint = a("../constraint/Constraint"), d.MouseConstraint = a("../constraint/MouseConstraint"), d.Common = a("../core/Common"), d.Engine = a("../core/Engine"), d.Events = a("../core/Events"), d.Mouse = a("../core/Mouse"), d.Runner = a("../core/Runner"), d.Sleeping = a("../core/Sleeping"), d.Bodies = a("../factory/Bodies"), d.Composites = a("../factory/Composites"), d.Axes = a("../geometry/Axes"), d.Bounds = a("../geometry/Bounds"), d.Svg = a("../geometry/Svg"), d.Vector = a("../geometry/Vector"), d.Vertices = a("../geometry/Vertices"), d.Render = a("../render/Render"), d.RenderPixi = a("../render/RenderPixi"), d.World.add = d.Composite.add, d.World.remove = d.Composite.remove, d.World.addComposite = d.Composite.addComposite, d.World.addBody = d.Composite.addBody, d.World.addConstraint = d.Composite.addConstraint, d.World.clear = d.Composite.clear, d.Engine.run = d.Runner.run }, { "../body/Body": 1, "../body/Composite": 2, "../body/World": 3, "../collision/Contact": 4, "../collision/Detector": 5, "../collision/Grid": 6, "../collision/Pair": 7, "../collision/Pairs": 8, "../collision/Query": 9, "../collision/Resolver": 10, "../collision/SAT": 11, "../constraint/Constraint": 12, "../constraint/MouseConstraint": 13, "../core/Common": 14, "../core/Engine": 15, "../core/Events": 16, "../core/Metrics": 17, "../core/Mouse": 18, "../core/Runner": 19, "../core/Sleeping": 20, "../factory/Bodies": 21, "../factory/Composites": 22, "../geometry/Axes": 23, "../geometry/Bounds": 24, "../geometry/Svg": 25, "../geometry/Vector": 26, "../geometry/Vertices": 27, "../render/Render": 29, "../render/RenderPixi": 30 }], 29: [function (a, b, c) {
      var d = {}; b.exports = d; var e = a("../core/Common"), f = a("../body/Composite"), g = a("../geometry/Bounds"), h = a("../core/Events"), i = a("../collision/Grid"); !function () {
      d.create = function (b) { var c = { controller: d, element: null, canvas: null, options: { width: 800, height: 600, pixelRatio: 1, background: "#fafafa", wireframeBackground: "#222", hasBounds: !1, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showBroadphase: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showSeparations: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showShadows: !1, showVertexNumbers: !1, showConvexHulls: !1, showInternalEdges: !1 } }, f = e.extend(c, b); return f.canvas = f.canvas || a(f.options.width, f.options.height), f.context = f.canvas.getContext("2d"), f.textures = {}, f.bounds = f.bounds || { min: { x: 0, y: 0 }, max: { x: f.options.width, y: f.options.height } }, 1 !== f.options.pixelRatio && d.setPixelRatio(f, f.options.pixelRatio), e.isElement(f.element) ? f.element.appendChild(f.canvas) : e.log("Render.create: options.element was undefined, render.canvas was created but not appended", "warn"), f }, d.setPixelRatio = function (a, c) { var d = a.options, e = a.canvas; "auto" === c && (c = b(e)), d.pixelRatio = c, e.setAttribute("data-pixel-ratio", c), e.width = d.width * c, e.height = d.height * c, e.style.width = d.width + "px", e.style.height = d.height + "px", a.context.scale(c, c) }, d.world = function (a) { var b, c = a.render, e = a.world, k = c.canvas, l = c.context, m = c.options, n = f.allBodies(e), o = f.allConstraints(e), p = m.wireframes ? m.wireframeBackground : m.background, q = [], r = [], s = { timestamp: a.timing.timestamp }; if (h.trigger(c, "beforeRender", s), c.currentBackground !== p && j(c, p), l.globalCompositeOperation = "source-in", l.fillStyle = "transparent", l.fillRect(0, 0, k.width, k.height), l.globalCompositeOperation = "source-over", m.hasBounds) { var t = c.bounds.max.x - c.bounds.min.x, u = c.bounds.max.y - c.bounds.min.y, v = t / m.width, w = u / m.height; for (b = 0; b < n.length; b++) { var x = n[b]; g.overlaps(x.bounds, c.bounds) && q.push(x) } for (b = 0; b < o.length; b++) { var y = o[b], z = y.bodyA, A = y.bodyB, B = y.pointA, C = y.pointB; z && (B = Vector.add(z.position, y.pointA)), A && (C = Vector.add(A.position, y.pointB)), B && C && (g.contains(c.bounds, B) || g.contains(c.bounds, C)) && r.push(y) } l.scale(1 / v, 1 / w), l.translate(-c.bounds.min.x, -c.bounds.min.y) } else r = o, q = n; !m.wireframes || a.enableSleeping && m.showSleeping ? d.bodies(a, q, l) : (m.showConvexHulls && d.bodyConvexHulls(a, q, l), d.bodyWireframes(a, q, l)), m.showBounds && d.bodyBounds(a, q, l), (m.showAxes || m.showAngleIndicator) && d.bodyAxes(a, q, l), m.showPositions && d.bodyPositions(a, q, l), m.showVelocity && d.bodyVelocity(a, q, l), m.showIds && d.bodyIds(a, q, l), m.showSeparations && d.separations(a, a.pairs.list, l), m.showCollisions && d.collisions(a, a.pairs.list, l), m.showVertexNumbers && d.vertexNumbers(a, q, l), d.constraints(r, l), m.showBroadphase && a.broadphase.controller === i && d.grid(a, a.broadphase, l), m.showDebug && d.debug(a, l), m.hasBounds && l.setTransform(m.pixelRatio, 0, 0, m.pixelRatio, 0, 0), h.trigger(c, "afterRender", s) }, d.debug = function (a, b) { var c = b, d = a.world, e = a.render, g = a.metrics, h = e.options, i = (f.allBodies(d), "    "); if (a.timing.timestamp - (e.debugTimestamp || 0) >= 500) { var j = ""; j += "fps: " + Math.round(g.timing.fps) + i, e.debugString = j, e.debugTimestamp = a.timing.timestamp } if (e.debugString) { c.font = "12px Arial", h.wireframes ? c.fillStyle = "rgba(255,255,255,0.5)" : c.fillStyle = "rgba(0,0,0,0.5)"; for (var k = e.debugString.split("\n"), l = 0; l < k.length; l++)c.fillText(k[l], 50, 50 + 18 * l) } }, d.constraints = function (a, b) { for (var c = b, d = 0; d < a.length; d++) { var e = a[d]; if (e.render.visible && e.pointA && e.pointB) { var f = e.bodyA, g = e.bodyB; f ? (c.beginPath(), c.moveTo(f.position.x + e.pointA.x, f.position.y + e.pointA.y)) : (c.beginPath(), c.moveTo(e.pointA.x, e.pointA.y)), g ? c.lineTo(g.position.x + e.pointB.x, g.position.y + e.pointB.y) : c.lineTo(e.pointB.x, e.pointB.y), c.lineWidth = e.render.lineWidth, c.strokeStyle = e.render.strokeStyle, c.stroke() } } }, d.bodyShadows = function (a, b, c) { for (var d = c, e = a.render, f = 0; f < b.length; f++) { var g = b[f]; if (g.render.visible) { if (g.circleRadius) d.beginPath(), d.arc(g.position.x, g.position.y, g.circleRadius, 0, 2 * Math.PI), d.closePath(); else { d.beginPath(), d.moveTo(g.vertices[0].x, g.vertices[0].y); for (var h = 1; h < g.vertices.length; h++)d.lineTo(g.vertices[h].x, g.vertices[h].y); d.closePath() } var i = g.position.x - .5 * e.options.width, j = g.position.y - .2 * e.options.height, k = Math.abs(i) + Math.abs(j); d.shadowColor = "rgba(0,0,0,0.15)", d.shadowOffsetX = .05 * i, d.shadowOffsetY = .05 * j, d.shadowBlur = 1 + 12 * Math.min(1, k / 1e3), d.fill(), d.shadowColor = null, d.shadowOffsetX = null, d.shadowOffsetY = null, d.shadowBlur = null } } }, d.bodies = function (a, b, d) { var f, g, h, i, j = d, k = a.render, l = k.options; for (h = 0; h < b.length; h++)if (f = b[h], f.render.visible) for (i = f.parts.length > 1 ? 1 : 0; i < f.parts.length; i++)if (g = f.parts[i], g.render.sprite && g.render.sprite.texture && !l.wireframes) { var m = g.render.sprite, n = c(k, m.texture); l.showSleeping && f.isSleeping && (j.globalAlpha = .5), j.translate(g.position.x, g.position.y), j.rotate(g.angle), j.drawImage(n, n.width * -.5 * m.xScale, n.height * -.5 * m.yScale, n.width * m.xScale, n.height * m.yScale), j.rotate(-g.angle), j.translate(-g.position.x, -g.position.y), l.showSleeping && f.isSleeping && (j.globalAlpha = 1) } else { if (g.circleRadius) j.beginPath(), j.arc(g.position.x, g.position.y, g.circleRadius, 0, 2 * Math.PI); else { j.beginPath(), j.moveTo(g.vertices[0].x, g.vertices[0].y); for (var o = 1; o < g.vertices.length; o++)j.lineTo(g.vertices[o].x, g.vertices[o].y); j.closePath() } l.wireframes ? (j.lineWidth = 1, j.strokeStyle = "#bbb", l.showSleeping && f.isSleeping && (j.strokeStyle = "rgba(255,255,255,0.2)"), j.stroke()) : (l.showSleeping && f.isSleeping ? j.fillStyle = e.shadeColor(g.render.fillStyle, 50) : j.fillStyle = g.render.fillStyle, j.lineWidth = g.render.lineWidth, j.strokeStyle = g.render.strokeStyle, j.fill(), j.stroke()) } }, d.bodyWireframes = function (a, b, c) { var d, e, f, g, h, i = c, j = a.render.options.showInternalEdges; for (i.beginPath(), f = 0; f < b.length; f++)if (d = b[f], d.render.visible) for (h = d.parts.length > 1 ? 1 : 0; h < d.parts.length; h++) { for (e = d.parts[h], i.moveTo(e.vertices[0].x, e.vertices[0].y), g = 1; g < e.vertices.length; g++)!e.vertices[g - 1].isInternal || j ? i.lineTo(e.vertices[g].x, e.vertices[g].y) : i.moveTo(e.vertices[g].x, e.vertices[g].y), e.vertices[g].isInternal && !j && i.moveTo(e.vertices[(g + 1) % e.vertices.length].x, e.vertices[(g + 1) % e.vertices.length].y); i.lineTo(e.vertices[0].x, e.vertices[0].y) } i.lineWidth = 1, i.strokeStyle = "#bbb", i.stroke() }, d.bodyConvexHulls = function (a, b, c) {
        var d, e, f, g = c; for (g.beginPath(),
          e = 0; e < b.length; e++)if (d = b[e], d.render.visible && 1 !== d.parts.length) { for (g.moveTo(d.vertices[0].x, d.vertices[0].y), f = 1; f < d.vertices.length; f++)g.lineTo(d.vertices[f].x, d.vertices[f].y); g.lineTo(d.vertices[0].x, d.vertices[0].y) } g.lineWidth = 1, g.strokeStyle = "rgba(255,255,255,0.2)", g.stroke()
      }, d.vertexNumbers = function (a, b, c) { var d, e, f, g = c; for (d = 0; d < b.length; d++) { var h = b[d].parts; for (f = h.length > 1 ? 1 : 0; f < h.length; f++) { var i = h[f]; for (e = 0; e < i.vertices.length; e++)g.fillStyle = "rgba(255,255,255,0.2)", g.fillText(d + "_" + e, i.position.x + .8 * (i.vertices[e].x - i.position.x), i.position.y + .8 * (i.vertices[e].y - i.position.y)) } } }, d.bodyBounds = function (a, b, c) { var d = c, e = a.render, f = e.options; d.beginPath(); for (var g = 0; g < b.length; g++) { var h = b[g]; if (h.render.visible) for (var i = b[g].parts, j = i.length > 1 ? 1 : 0; j < i.length; j++) { var k = i[j]; d.rect(k.bounds.min.x, k.bounds.min.y, k.bounds.max.x - k.bounds.min.x, k.bounds.max.y - k.bounds.min.y) } } f.wireframes ? d.strokeStyle = "rgba(255,255,255,0.08)" : d.strokeStyle = "rgba(0,0,0,0.1)", d.lineWidth = 1, d.stroke() }, d.bodyAxes = function (a, b, c) { var d, e, f, g, h = c, i = a.render, j = i.options; for (h.beginPath(), e = 0; e < b.length; e++) { var k = b[e], l = k.parts; if (k.render.visible) if (j.showAxes) for (f = l.length > 1 ? 1 : 0; f < l.length; f++)for (d = l[f], g = 0; g < d.axes.length; g++) { var m = d.axes[g]; h.moveTo(d.position.x, d.position.y), h.lineTo(d.position.x + 20 * m.x, d.position.y + 20 * m.y) } else for (f = l.length > 1 ? 1 : 0; f < l.length; f++)for (d = l[f], g = 0; g < d.axes.length; g++)h.moveTo(d.position.x, d.position.y), h.lineTo((d.vertices[0].x + d.vertices[d.vertices.length - 1].x) / 2, (d.vertices[0].y + d.vertices[d.vertices.length - 1].y) / 2) } j.wireframes ? h.strokeStyle = "indianred" : h.strokeStyle = "rgba(0,0,0,0.3)", h.lineWidth = 1, h.stroke() }, d.bodyPositions = function (a, b, c) { var d, e, f, g, h = c, i = a.render, j = i.options; for (h.beginPath(), f = 0; f < b.length; f++)if (d = b[f], d.render.visible) for (g = 0; g < d.parts.length; g++)e = d.parts[g], h.arc(e.position.x, e.position.y, 3, 0, 2 * Math.PI, !1), h.closePath(); for (j.wireframes ? h.fillStyle = "indianred" : h.fillStyle = "rgba(0,0,0,0.5)", h.fill(), h.beginPath(), f = 0; f < b.length; f++)d = b[f], d.render.visible && (h.arc(d.positionPrev.x, d.positionPrev.y, 2, 0, 2 * Math.PI, !1), h.closePath()); h.fillStyle = "rgba(255,165,0,0.8)", h.fill() }, d.bodyVelocity = function (a, b, c) { var d = c; d.beginPath(); for (var e = 0; e < b.length; e++) { var f = b[e]; f.render.visible && (d.moveTo(f.position.x, f.position.y), d.lineTo(f.position.x + 2 * (f.position.x - f.positionPrev.x), f.position.y + 2 * (f.position.y - f.positionPrev.y))) } d.lineWidth = 3, d.strokeStyle = "cornflowerblue", d.stroke() }, d.bodyIds = function (a, b, c) { var d, e, f = c; for (d = 0; d < b.length; d++)if (b[d].render.visible) { var g = b[d].parts; for (e = g.length > 1 ? 1 : 0; e < g.length; e++) { var h = g[e]; f.font = "12px Arial", f.fillStyle = "rgba(255,255,255,0.5)", f.fillText(h.id, h.position.x + 10, h.position.y - 10) } } }, d.collisions = function (a, b, c) { var d, e, f, g, h = c, i = a.render.options; for (h.beginPath(), f = 0; f < b.length; f++)if (d = b[f], d.isActive) for (e = d.collision, g = 0; g < d.activeContacts.length; g++) { var j = d.activeContacts[g], k = j.vertex; h.rect(k.x - 1.5, k.y - 1.5, 3.5, 3.5) } for (i.wireframes ? h.fillStyle = "rgba(255,255,255,0.7)" : h.fillStyle = "orange", h.fill(), h.beginPath(), f = 0; f < b.length; f++)if (d = b[f], d.isActive && (e = d.collision, d.activeContacts.length > 0)) { var l = d.activeContacts[0].vertex.x, m = d.activeContacts[0].vertex.y; 2 === d.activeContacts.length && (l = (d.activeContacts[0].vertex.x + d.activeContacts[1].vertex.x) / 2, m = (d.activeContacts[0].vertex.y + d.activeContacts[1].vertex.y) / 2), e.bodyB === e.supports[0].body || e.bodyA.isStatic === !0 ? h.moveTo(l - 8 * e.normal.x, m - 8 * e.normal.y) : h.moveTo(l + 8 * e.normal.x, m + 8 * e.normal.y), h.lineTo(l, m) } i.wireframes ? h.strokeStyle = "rgba(255,165,0,0.7)" : h.strokeStyle = "orange", h.lineWidth = 1, h.stroke() }, d.separations = function (a, b, c) { var d, e, f, g, h, i = c, j = a.render.options; for (i.beginPath(), h = 0; h < b.length; h++)if (d = b[h], d.isActive) { e = d.collision, f = e.bodyA, g = e.bodyB; var k = 1; g.isStatic || f.isStatic || (k = .5), g.isStatic && (k = 0), i.moveTo(g.position.x, g.position.y), i.lineTo(g.position.x - e.penetration.x * k, g.position.y - e.penetration.y * k), k = 1, g.isStatic || f.isStatic || (k = .5), f.isStatic && (k = 0), i.moveTo(f.position.x, f.position.y), i.lineTo(f.position.x + e.penetration.x * k, f.position.y + e.penetration.y * k) } j.wireframes ? i.strokeStyle = "rgba(255,165,0,0.5)" : i.strokeStyle = "orange", i.stroke() }, d.grid = function (a, b, c) { var d = c, f = a.render.options; f.wireframes ? d.strokeStyle = "rgba(255,180,0,0.1)" : d.strokeStyle = "rgba(255,180,0,0.5)", d.beginPath(); for (var g = e.keys(b.buckets), h = 0; h < g.length; h++) { var i = g[h]; if (!(b.buckets[i].length < 2)) { var j = i.split(","); d.rect(.5 + parseInt(j[0], 10) * b.bucketWidth, .5 + parseInt(j[1], 10) * b.bucketHeight, b.bucketWidth, b.bucketHeight) } } d.lineWidth = 1, d.stroke() }, d.inspector = function (a, b) { var c, d = a.engine, e = a.selected, f = d.render, g = f.options; if (g.hasBounds) { var h = f.bounds.max.x - f.bounds.min.x, i = f.bounds.max.y - f.bounds.min.y, j = h / f.options.width, k = i / f.options.height; b.scale(1 / j, 1 / k), b.translate(-f.bounds.min.x, -f.bounds.min.y) } for (var l = 0; l < e.length; l++) { var m = e[l].data; switch (b.translate(.5, .5), b.lineWidth = 1, b.strokeStyle = "rgba(255,165,0,0.9)", b.setLineDash([1, 2]), m.type) { case "body": c = m.bounds, b.beginPath(), b.rect(Math.floor(c.min.x - 3), Math.floor(c.min.y - 3), Math.floor(c.max.x - c.min.x + 6), Math.floor(c.max.y - c.min.y + 6)), b.closePath(), b.stroke(); break; case "constraint": var n = m.pointA; m.bodyA && (n = m.pointB), b.beginPath(), b.arc(n.x, n.y, 10, 0, 2 * Math.PI), b.closePath(), b.stroke() }b.setLineDash([]), b.translate(-.5, -.5) } null !== a.selectStart && (b.translate(.5, .5), b.lineWidth = 1, b.strokeStyle = "rgba(255,165,0,0.6)", b.fillStyle = "rgba(255,165,0,0.1)", c = a.selectBounds, b.beginPath(), b.rect(Math.floor(c.min.x), Math.floor(c.min.y), Math.floor(c.max.x - c.min.x), Math.floor(c.max.y - c.min.y)), b.closePath(), b.stroke(), b.fill(), b.translate(-.5, -.5)), g.hasBounds && b.setTransform(1, 0, 0, 1, 0, 0) }; var a = function (a, b) { var c = document.createElement("canvas"); return c.width = a, c.height = b, c.oncontextmenu = function () { return !1 }, c.onselectstart = function () { return !1 }, c }, b = function (a) { var b = a.getContext("2d"), c = window.devicePixelRatio || 1, d = b.webkitBackingStorePixelRatio || b.mozBackingStorePixelRatio || b.msBackingStorePixelRatio || b.oBackingStorePixelRatio || b.backingStorePixelRatio || 1; return c / d }, c = function (a, b) { var c = a.textures[b]; return c ? c : (c = a.textures[b] = new Image, c.src = b, c) }, j = function (a, b) { var c = b; /(jpg|gif|png)$/.test(b) && (c = "url(" + b + ")"), a.canvas.style.background = c, a.canvas.style.backgroundSize = "contain", a.currentBackground = b }
      }()
    }, { "../body/Composite": 2, "../collision/Grid": 6, "../core/Common": 14, "../core/Events": 16, "../geometry/Bounds": 24 }], 30: [function (a, b, c) { var d = {}; b.exports = d; var e = a("../body/Composite"), f = a("../core/Common"); !function () { d.create = function (a) { var b = { controller: d, element: null, canvas: null, options: { width: 800, height: 600, background: "#fafafa", wireframeBackground: "#222", hasBounds: !1, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showBroadphase: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showShadows: !1 } }, c = f.extend(b, a), e = !c.options.wireframes && "transparent" === c.options.background; return c.context = new PIXI.WebGLRenderer(c.options.width, c.options.height, { view: c.canvas, transparent: e, antialias: !0, backgroundColor: a.background }), c.canvas = c.context.view, c.container = new PIXI.Container, c.bounds = c.bounds || { min: { x: 0, y: 0 }, max: { x: c.options.width, y: c.options.height } }, c.textures = {}, c.sprites = {}, c.primitives = {}, c.spriteContainer = new PIXI.Container, c.container.addChild(c.spriteContainer), f.isElement(c.element) ? c.element.appendChild(c.canvas) : f.log('No "render.element" passed, "render.canvas" was not inserted into document.', "warn"), c.canvas.oncontextmenu = function () { return !1 }, c.canvas.onselectstart = function () { return !1 }, c }, d.clear = function (a) { for (var b = a.container, c = a.spriteContainer; b.children[0];)b.removeChild(b.children[0]); for (; c.children[0];)c.removeChild(c.children[0]); var d = a.sprites["bg-0"]; a.textures = {}, a.sprites = {}, a.primitives = {}, a.sprites["bg-0"] = d, d && b.addChildAt(d, 0), a.container.addChild(a.spriteContainer), a.currentBackground = null, b.scale.set(1, 1), b.position.set(0, 0) }, d.setBackground = function (a, b) { if (a.currentBackground !== b) { var d = b.indexOf && -1 !== b.indexOf("#"), e = a.sprites["bg-0"]; if (d) { var g = f.colorToNumber(b); a.context.backgroundColor = g, e && a.container.removeChild(e) } else if (!e) { var h = c(a, b); e = a.sprites["bg-0"] = new PIXI.Sprite(h), e.position.x = 0, e.position.y = 0, a.container.addChildAt(e, 0) } a.currentBackground = b } }, d.world = function (a) { var b, c = a.render, f = a.world, g = c.context, h = c.container, i = c.options, j = e.allBodies(f), k = e.allConstraints(f), l = []; i.wireframes ? d.setBackground(c, i.wireframeBackground) : d.setBackground(c, i.background); var m = c.bounds.max.x - c.bounds.min.x, n = c.bounds.max.y - c.bounds.min.y, o = m / c.options.width, p = n / c.options.height; if (i.hasBounds) { for (b = 0; b < j.length; b++) { var q = j[b]; q.render.sprite.visible = Bounds.overlaps(q.bounds, c.bounds) } for (b = 0; b < k.length; b++) { var r = k[b], s = r.bodyA, t = r.bodyB, u = r.pointA, v = r.pointB; s && (u = Vector.add(s.position, r.pointA)), t && (v = Vector.add(t.position, r.pointB)), u && v && (Bounds.contains(c.bounds, u) || Bounds.contains(c.bounds, v)) && l.push(r) } h.scale.set(1 / o, 1 / p), h.position.set(-c.bounds.min.x * (1 / o), -c.bounds.min.y * (1 / p)) } else l = k; for (b = 0; b < j.length; b++)d.body(a, j[b]); for (b = 0; b < l.length; b++)d.constraint(a, l[b]); g.render(h) }, d.constraint = function (a, b) { var c = a.render, d = b.bodyA, e = b.bodyB, g = b.pointA, h = b.pointB, i = c.container, j = b.render, k = "c-" + b.id, l = c.primitives[k]; return l || (l = c.primitives[k] = new PIXI.Graphics), j.visible && b.pointA && b.pointB ? (-1 === f.indexOf(i.children, l) && i.addChild(l), l.clear(), l.beginFill(0, 0), l.lineStyle(j.lineWidth, f.colorToNumber(j.strokeStyle), 1), d ? l.moveTo(d.position.x + g.x, d.position.y + g.y) : l.moveTo(g.x, g.y), e ? l.lineTo(e.position.x + h.x, e.position.y + h.y) : l.lineTo(h.x, h.y), void l.endFill()) : void l.clear() }, d.body = function (c, d) { var e = c.render, g = d.render; if (g.visible) if (g.sprite && g.sprite.texture) { var h = "b-" + d.id, i = e.sprites[h], j = e.spriteContainer; i || (i = e.sprites[h] = a(e, d)), -1 === f.indexOf(j.children, i) && j.addChild(i), i.position.x = d.position.x, i.position.y = d.position.y, i.rotation = d.angle, i.scale.x = g.sprite.xScale || 1, i.scale.y = g.sprite.yScale || 1 } else { var k = "b-" + d.id, l = e.primitives[k], m = e.container; l || (l = e.primitives[k] = b(e, d), l.initialAngle = d.angle), -1 === f.indexOf(m.children, l) && m.addChild(l), l.position.x = d.position.x, l.position.y = d.position.y, l.rotation = d.angle - l.initialAngle } }; var a = function (a, b) { var d = b.render, e = d.sprite.texture, f = c(a, e), g = new PIXI.Sprite(f); return g.anchor.x = .5, g.anchor.y = .5, g }, b = function (a, b) { var c, d = b.render, e = a.options, g = new PIXI.Graphics, h = f.colorToNumber(d.fillStyle), i = f.colorToNumber(d.strokeStyle), j = f.colorToNumber(d.strokeStyle), k = f.colorToNumber("#bbb"), l = f.colorToNumber("#CD5C5C"); g.clear(); for (var m = b.parts.length > 1 ? 1 : 0; m < b.parts.length; m++) { c = b.parts[m], e.wireframes ? (g.beginFill(0, 0), g.lineStyle(1, k, 1)) : (g.beginFill(h, 1), g.lineStyle(d.lineWidth, i, 1)), g.moveTo(c.vertices[0].x - b.position.x, c.vertices[0].y - b.position.y); for (var n = 1; n < c.vertices.length; n++)g.lineTo(c.vertices[n].x - b.position.x, c.vertices[n].y - b.position.y); g.lineTo(c.vertices[0].x - b.position.x, c.vertices[0].y - b.position.y), g.endFill(), (e.showAngleIndicator || e.showAxes) && (g.beginFill(0, 0), e.wireframes ? g.lineStyle(1, l, 1) : g.lineStyle(1, j), g.moveTo(c.position.x - b.position.x, c.position.y - b.position.y), g.lineTo((c.vertices[0].x + c.vertices[c.vertices.length - 1].x) / 2 - b.position.x, (c.vertices[0].y + c.vertices[c.vertices.length - 1].y) / 2 - b.position.y), g.endFill()) } return g }, c = function (a, b) { var c = a.textures[b]; return c || (c = a.textures[b] = PIXI.Texture.fromImage(b)), c } }() }, { "../body/Composite": 2, "../core/Common": 14 }]
  }, {}, [28])(28)
});